<!DOCTYPE html>
<html lang="en" style="background: rgba(24, 24, 24, 1);" class="loading-screen">
<head>
    <title>AI Face Swap: The Best, Free & Online | For Photo & Video</title>
    <link rel="canonical" href="https://deepany.ai/face-swap">

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="DeepAny.AI offers a free trial for creating realistic deepfake face swaps with cutting-edge AI technology. Easily swap faces in inputs and images with our user-friendly online ai tools. No technical skills required, start your free trial today!">
    <meta name="keywords" content="ai, deepany, face swap, free bodyswap, online photo editing, video face swap, gif swap, deepfake, AI face changer, image manipulation, AI-powered tools">

    <meta property="og:type" content="website">
    <meta property="og:url" content="https://deepany.ai">
    <meta property="og:locale" content="en_US">
    <meta property="og:site_name" content="DeepAny.AI">
    <meta property="og:title" content="DeepAny.AI | AI Service Solutions">
    <meta property="og:description" content="DeepAny.AI is your go-to platform for advanced AI solutions and services, accessible to everyone!">
    <meta property="og:image" content="https://deepany.ai/assets/brand.png">
    <meta property="og:image:alt" content="DeepAny.AI | Brand Logo">

    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://deepany.ai">
    <meta property="twitter:title" content="DeepAny.AI | AI Service Solutions">
    <meta property="twitter:description" content="DeepAny.AI is your go-to platform for advanced AI solutions and services, accessible to everyone!">
    <meta property="twitter:image" content="https://deepany.ai/assets/brand.png">

    <style id="loading-stylesheet">
        .loading-screen {
            position: fixed;
            top: 50%;
            left: 50%;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #ff7300;
            border-radius: 50%;
            width: 50px !important;
            height: 50px !important;
            animation: spin 2s linear infinite
        }

        @keyframes spin {
            0% {
                transform: translate(-50%, -50%) rotate(0deg);
            }

            100% {
                transform: translate(-50%, -50%) rotate(360deg);
            }
        }
    </style>
    <link rel="stylesheet" href="css/styles.css?v=1.3.2.3">
    <script>
        window.addEventListener('DOMContentLoaded', () => {
            const cssRules = Array.from(document.styleSheets).flatMap(sheet => Array.from(sheet.cssRules));
            const logoImgRule = cssRules.find(rule => rule.selectorText === '.logo img');

            if (logoImgRule && logoImgRule.style.content) {
                const content = logoImgRule.style.content;
                const base64Match = content.match(/url\("?([^"]+)"?\)/);

                if (base64Match && base64Match[1]) {
                    const icon = document.createElement('link');
                    icon.rel = 'icon';
                    icon.href = base64Match[1];
                    icon.type = 'image/x-icon';
                    icon.title = 'DeepAny.AI Favicon';
                    document.head.appendChild(icon);
                }
            }

            const currentScript = document.currentScript;
            if (currentScript) {
                currentScript.remove();
            }
        });
    </script>
</head>
<body lang="en">
    <script type="module" defer>
        const version = '1.3.2.3';

        async function loadModule(url) {
            return import(`${url}?v=${version}`);
        }

        document.addEventListener('DOMContentLoaded', async function () {
            const functions = await loadModule('./scripts/functions.js');
            const { showNotification, fetchProcessState, openDB, addToDB, countInDB, getFromDB, updateActiveState, initDB, updateInDB, updateChunksInDB, deleteFromDB, setUser, setCurrentUserDoc, getCachedStaticUserData, getCachedDynamicUserDoc, setAuthentication, getFirebaseModules, getDocSnapshot, getDocsSnapshot, getScreenMode, getCurrentMain, updateContent, ScreenMode, createPages, setNavbar, setSidebar, showSidebar, removeSidebar, getSidebarActive, moveMains, setupMainSize, loadScrollingAndMain, showZoomIndicator, setScaleFactors, clamp, loadPageContent, retrieveImageFromURL, fetchServerAddress, ensureUniqueId, getUserIpAddress, fetchServerAddresses, getPageName } = functions;

            if (!window.indexedDB) {
                alert('Your browser does not support IndexedDB.');
            }

            const pageName = getPageName();

            function savePageState() {
                const requiredIds = [
                    'enableOccluder',
                    'enableEnhancedAnalyzer',
                    'enableEnhancedLandmarks',
                    'removeBanner',
                    'showServers',
                    'skipSlowServers',
                    'keepFPS',
                    'ageModifier',
                    'fps-slider'
                ];

                if (!requiredIds.every(id => document.getElementById(id))) {
                    return;
                }

                const getCheckboxState = id => document.getElementById(id)?.checked || false;
                const activeLink = document.querySelector('.nav-links .active');
                const state = {
                    enableOccluder: getCheckboxState('enableOccluder'),
                    enableEnhancedAnalyzer: getCheckboxState('enableEnhancedAnalyzer'),
                    enableEnhancedLandmarks: getCheckboxState('enableEnhancedLandmarks'),
                    removeBanner: getCheckboxState('removeBanner'),
                    showServers: getCheckboxState('showServers'),
                    skipSlowServers: getCheckboxState('skipSlowServers'),
                    keepFPS: getCheckboxState('keepFPS'),
                    fpsValue: document.getElementById('fps-slider').value,
                    ageModifier: getCheckboxState('ageModifier'),
                    ageModifierValue: document.getElementById('age-modifier').value,
                    enhancerBlendValue: document.getElementById('enhancerBlendValue').value,
                    activeLink: activeLink?.getAttribute('for') || '',
                    multiboxes: Array.from(document.querySelectorAll('.multibox')).map(multibox => ({
                        text: multibox.querySelector('.multibox-text')?.innerText || '',
                        open: multibox.classList.contains('open'),
                        items: Array.from(multibox.querySelectorAll('.item')).map(item => ({
                            checked: item.querySelector('input[type="checkbox"]')?.checked || false,
                        })),
                    })),
                    comboboxes: Array.from(document.querySelectorAll('.combobox')).map(combobox => ({
                        text: combobox.querySelector('.combobox-text')?.innerText || '',
                        open: combobox.classList.contains('open'),
                        items: Array.from(combobox.querySelectorAll('.item')).map(item => ({
                            checked: item.querySelector('input[type="checkbox"]')?.checked || false,
                        })),
                    })),
                };

                localStorage.setItem(pageName, JSON.stringify(state));
            }

            let userData = getCachedStaticUserData();
            let userDoc = getCachedDynamicUserDoc();

            function updateMainContent(screenMode, pageContent) {
                pageContent.length = 0;
                pageContent.push(`                      <div id="baseContainer" class="centered-container">
                                                                                    <div class="background-container" style="display: flex;flex-direction: column;align-items: stretch;">
                                                                                        <div style="display: flex; gap: calc((1vh* var(--scale-factor-h) + 2vw / 2 * var(--scale-factor-w)));height: 100%;">
                                                                                            <div class="background-dot-container">
                                                                                                <div class="background-dot-container-content">
                                                                                                    <div style="display: flex;justify-content: space-between;">
                                                                                                        <div style="display: flex;flex-direction: column;align-items: center;">
                                                                                                            <div class="circular-button" id="circular-button-face-upload" title="Upload face" tooltip>
                                                                                                                <div class="tooltip">Add and choose the new face image to apply to the video or image input.</div>
                                                                                                                <input type="file" accept="image/*" id="face-upload" style="display: none" multiple>
                                                                                                            </div>
                                                                                                            <div class="faces"></div>
                                                                                                        </div>
                                                                                                        <div style="display: flex;flex-direction: column;align-items: center;">
                                                                                                            <div class="circular-button" id="circular-button-input-upload" title="Upload input" tooltip>
                                                                                                                <div class="tooltip">Add and choose the video or image where the face swap will occur.</div>
                                                                                                                <input type="file" accept="video/*,image/*" id="input-upload" style="display: none" multiple>
                                                                                                            </div>
                                                                                                            <div class="inputs"></div>
                                                                                                        </div>
                                                                                                    </div>
                                                                                                        <div class="line"></div>
                                                                                                        <div class="nav-links">
                                                                                                            <li><a class="text" for="Facial">Facial</a></li>
                                                                                                            <li><a class="text" for="Analyzer">Analyzer</a></li>
                                                                                                            <li><a class="text" for="Other">Other</a></li>
                                                                                                        </div>
                                                                                                        <div id="Facial" class="section" style="display: none;gap: calc(1vh* var(--scale-factor-h));">
                                                                                                            <div>
                                                                                                                <h4 style="font-weight: 400;">Facial Enhancer</h4>
                                                                                                                <div id="enhancement" class="combobox" tooltip style="gap: calc(1vh* var(--scale-factor-h));">
                                                                                                                    <div class="tooltip">Choose a face enhancement model to improve the facial features. Each option applies a different method for enhancing or restoring the face's appearance.</div>
                                                                                                                    <span class="combobox-text" title="Enhancement"></span>
                                                                                                                    <div id="enhancerBlendContainer" style="display: flex;align-items: center;flex-direction: row-reverse;gap: calc(1vh* var(--scale-factor-h));">
                                                                                                                        <input type="range" min="24" max="100" value="24" class="slider" id="enhancerBlendValue">
                                                                                                                        <div class="slider-value" id="enhancerBlendDisplayValue">Auto</div>
                                                                                                                    </div>
                                                                                                                    <span class="arrow-dwn"></span>
                                                                                                                    <ul class="list-items">
                                                                                                                        <li class="item">
                                                                                                                            <label class="checkbox" tooltip>
                                                                                                                                <input type="checkbox" id="natural_face_enhancer_1024"><span>Default</span>
                                                                                                                                <div class="tooltip">Preserves realistic details, in 2048x2048 resolution.</div>
                                                                                                                            </label>
                                                                                                                        </li>
                                                                                                                        <li class="item">
                                                                                                                            <label class="checkbox" tooltip>
                                                                                                                                <input type="checkbox" id="natural_face_enhancer_2048"><span>Detailed</span>
                                                                                                                                <div class="tooltip">Preserves realistic details, in 1024x1024 resolution.</div>
                                                                                                                            </label>
                                                                                                                        </li>
                                                                                                                        <li class="item">
                                                                                                                            <label class="checkbox" tooltip>
                                                                                                                                <input type="checkbox" id="natural_face_enhancer_512"><span>Natural</span>
                                                                                                                                <div class="tooltip">Preserves realistic details, in 512x512 resolution.</div>
                                                                                                                            </label>
                                                                                                                        </li>
                                                                                                                        <li class="item">
                                                                                                                            <label class="checkbox" tooltip>
                                                                                                                                <input type="checkbox" id="smooth_face_enhancer"><span>Smooth</span>
                                                                                                                                <div class="tooltip">Applies smoothing techniques for a refined and polished look.</div>
                                                                                                                            </label>
                                                                                                                        </li>
                                                                                                                    </ul>
                                                                                                                </div>
                                                                                                            </div>
                                                                                                            <div>
                                                                                                                <h4 style="font-weight: 400;">Pixel boost</h4>
                                                                                                                <div class="combobox" tooltip>
                                                                                                                    <div class="tooltip">
                                                                                                                        The addition of a "pixel boost" option enhances the resolution of swapped faces, making results more realistic and detailed.
                                                                                                                    </div>
                                                                                                                    <span class="combobox-text" title="Pixel boost"></span>
                                                                                                                    <span class="arrow-dwn"></span>
                                                                                                                    <ul class="list-items">
                                                                                                                        <li class="item">
                                                                                                                            <label class="checkbox" tooltip>
                                                                                                                                <input type="checkbox" id="pixelBoost256x256"><span>256x256</span>
                                                                                                                                <div class="tooltip">Takes 2x longer, but the quality and detail improves.</div>
                                                                                                                            </label>
                                                                                                                        </li>
                                                                                                                        <li class="item">
                                                                                                                            <label class="checkbox" tooltip>
                                                                                                                                <input type="checkbox" id="pixelBoost512x512"><span>512x512</span>
                                                                                                                                <div class="tooltip">Takes 4x longer, with significantly improved quality and details.</div>
                                                                                                                            </label>
                                                                                                                        </li>
                                                                                                                        <li class="item">
                                                                                                                            <label class="checkbox" tooltip>
                                                                                                                                <input type="checkbox" id="pixelBoost1024x1024"><span>1024x1024</span>
                                                                                                                                <div class="tooltip">Takes 8x longer, resulting in the highest quality and details.</div>
                                                                                                                            </label>
                                                                                                                        </li>
                                                                                                                    </ul>
                                                                                                                </div>
                                                                                                            </div>
                                                                                                            <div id="facialCheckboxes" style="display: flex;gap: calc(1.5vh* var(--scale-factor-h));flex-direction: column;">
                                                                                                                <div style="width: 100%;">
                                                                                                                    <h4 style="font-weight: 400;">Improved Landmarks</h4>
                                                                                                                    <label class="checkbox" tooltip>
                                                                                                                        <input type="checkbox" id="enableEnhancedLandmarks"><span>68 Landmarks</span>
                                                                                                                        <div class="tooltip">By enabling this feature, the system can more accurately identify and analyze specific facial components such as the eyebrows, eyes, nose, mouth, and jawline. It helps decreasing jitters in the face.</div>
                                                                                                                    </label>
                                                                                                                </div>
                                                                                                                <div style="width: 100%;">
                                                                                                                    <h4 style="font-weight: 400;">Facial Occlusion</h4>
                                                                                                                    <label class="checkbox" tooltip>
                                                                                                                        <input type="checkbox" id="enableOccluder"><span>Obstruction Detection</span>
                                                                                                                        <div class="tooltip">Detects obstructing objects in front of the face, but this can cause slight unsimilarity as it will retain the unswapped original person's facial outline.</div>
                                                                                                                    </label>
                                                                                                                </div>
                                                                                                            </div>
                                                                                                            <label class="checkbox" tooltip style="display: none;align-items: center;gap: calc(1.5vh* var(--scale-factor-h));justify-content: space-between;">
                                                                                                                <div class="tooltip">Slide left to decrease to younger age (up to -100%) and slide right to increase to older age (up to +100%).</div>
                                                                                                                <div style="display: flex;align-items: center;">
                                                                                                                    <input type="checkbox" id="ageModifier">
                                                                                                                    <span>Modify Age</span>
                                                                                                                </div>
                                                                                                                <div id="ageModifierContainer" style="display: flex;align-items: center;flex-direction: row-reverse;gap: calc(1.5vh* var(--scale-factor-h));">
                                                                                                                    <input type="range" min="-100" max="100" value="0" class="slider" id="age-modifier">
                                                                                                                    <div class="slider-value" id="age-modifier-value">0</div>
                                                                                                                </div>
                                                                                                            </label>
                                                                                                        </div>
                                                                                                        <div id="Analyzer" class="section" style="display: none;position: relative;flex-direction: column;gap: calc(1vh* var(--scale-factor-h));">
                                                                                                            <div>
                                                                                                                <h4 style="font-weight: 400;">Select Regions</h4>
                                                                                                                <div class="multibox" tooltip>
                                                                                                                    <div class="tooltip">Select regions to customize in the new face. If an area is not enabled, it will remain unchanged from the original face.</div>
                                                                                                                    <span class="multibox-text" title="Select Regions"></span>
                                                                                                                    <span class="arrow-dwn"></span>
                                                                                                                    <ul class="list-items">
                                                                                                                        <li class="item">
                                                                                                                            <label class="checkbox" tooltip>
                                                                                                                                <input type="checkbox" id="skin"><span>Change Skin</span>
                                                                                                                                <div class="tooltip">Swap the skin area with the new face.</div>
                                                                                                                            </label>
                                                                                                                        </li>
                                                                                                                        <li class="item">
                                                                                                                            <label class="checkbox" tooltip>
                                                                                                                                <input type="checkbox" id="eyebrow"><span>Change Eyebrow</span>
                                                                                                                                <div class="tooltip">Replace the eyebrow shape or color.</div>
                                                                                                                            </label>
                                                                                                                        </li>
                                                                                                                        <li class="item">
                                                                                                                            <label class="checkbox" tooltip>
                                                                                                                                <input type="checkbox" id="eye"><span>Change Eye</span>
                                                                                                                                <div class="tooltip">Change the eye appearance.</div>
                                                                                                                            </label>
                                                                                                                        </li>
                                                                                                                        <li class="item">
                                                                                                                            <label class="checkbox" tooltip>
                                                                                                                                <input type="checkbox" id="glasses"><span>Change Glasses</span>
                                                                                                                                <div class="tooltip">Modify or add eyewear styles.</div>
                                                                                                                            </label>
                                                                                                                        </li>
                                                                                                                        <li class="item">
                                                                                                                            <label class="checkbox" tooltip>
                                                                                                                                <input type="checkbox" id="nose"><span>Change Nose</span>
                                                                                                                                <div class="tooltip">Alter the nose shape or size.</div>
                                                                                                                            </label>
                                                                                                                        </li>
                                                                                                                        <li class="item">
                                                                                                                            <label class="checkbox" tooltip>
                                                                                                                                <input type="checkbox" id="mouth"><span>Change Mouth</span>
                                                                                                                                <div class="tooltip">Change the shape or expression of the mouth.</div>
                                                                                                                            </label>
                                                                                                                        </li>
                                                                                                                        <li class="item">
                                                                                                                            <label class="checkbox" tooltip>
                                                                                                                                <input type="checkbox" id="lip"><span>Change Lip</span>
                                                                                                                                <div class="tooltip">Adjust the color or shape of the lips.</div>
                                                                                                                            </label>
                                                                                                                        </li>
                                                                                                                    </ul>
                                                                                                                </div>
                                                                                                            </div>
                                                                                                            <div>
                                                                                                                <h4 style="font-weight: 400;">Select Orientation</h4>
                                                                                                                <div class="multibox" tooltip>
                                                                                                                    <div class="tooltip">Select head orientation to improve the analysis of the input video. Rotates the input to get the frontal head rotation.</div>
                                                                                                                    <span class="multibox-text" title="Orientation"></span>
                                                                                                                    <span class="arrow-dwn"></span>
                                                                                                                    <ul class="list-items">
                                                                                                                        <li class="item">
                                                                                                                            <label class="checkbox" tooltip>
                                                                                                                                <input type="checkbox" id="frontalRotation" checked disabled><span>Frontal Head (0째)</span>
                                                                                                                                <div class="tooltip">The face is facing forward. Best for accurate analysis.</div>
                                                                                                                            </label>
                                                                                                                        </li>
                                                                                                                        <li class="item">
                                                                                                                            <label class="checkbox" tooltip>
                                                                                                                                <input type="checkbox" id="rightRotation"><span>Tilted Right Head (90째)</span>
                                                                                                                                <div class="tooltip">Select this if the face in the input is tilted to the right.</div>
                                                                                                                            </label>
                                                                                                                        </li>
                                                                                                                        <li class="item">
                                                                                                                            <label class="checkbox" tooltip>
                                                                                                                                <input type="checkbox" id="invertedRotation"><span>Inverted Head (180째)</span>
                                                                                                                                <div class="tooltip">Select this if the face in the input is upside down.</div>
                                                                                                                            </label>
                                                                                                                        </li>
                                                                                                                        <li class="item">
                                                                                                                            <label class="checkbox" tooltip>
                                                                                                                                <div class="tooltip">Select this if the face in the input is tilted to the left.</div>
                                                                                                                                <input type="checkbox" id="leftRotation"><span>Tilted Left Head (-90째)</span>
                                                                                                                            </label>
                                                                                                                        </li>
                                                                                                                    </ul>
                                                                                                                </div>
                                                                                                            </div>
                                                                                                            <div>
                                                                                                                <h4 style="font-weight: 400;">Enhanced Analyzer</h4>
                                                                                                                <label class="checkbox" tooltip>
                                                                                                                    <input type="checkbox" id="enableEnhancedAnalyzer"><span>Multiple Face Detectors</span>
                                                                                                                    <div class="tooltip">Use multiple detection algorithms (like YoloFace, RetinaFace, SCRFD) to get the best results. It helps decreasing flickerings.</div>
                                                                                                                </label>
                                                                                                            </div>
                                                                                                        </div>
                                                                                                        <div id="Other" class="section" style="display: none;gap: calc(1vh* var(--scale-factor-h));">
                                                                                                            <div>
                                                                                                                <h4 style="font-weight: 400;">Remove Banner</h4>
                                                                                                                <label class="checkbox">
                                                                                                                    <input type="checkbox" id="removeBanner"><span>Remove banner</span>
                                                                                                                </label>
                                                                                                            </div>
                                                                                                            <div>
                                                                                                                <h4 style="font-weight: 400;">Keep Frames Per Second</h4>
                                                                                                                <label class="checkbox" style="display: flex;align-items: center;gap: calc(1vh* var(--scale-factor-h));justify-content: space-between;">
                                                                                                                    <div style="display: flex;align-items: center;"><input type="checkbox" id="keepFPS"><span>Keep FPS</span></div>
                                                                                                                    <div id="keepFPSContainer" style="display: flex;align-items: center;flex-direction: row-reverse;gap: calc(1vh* var(--scale-factor-h));">
                                                                                                                        <input type="range" min="1" max="60" value="30" class="slider" id="fps-slider">
                                                                                                                        <div class="slider-value" id="fps-value">30</div>
                                                                                                                    </div>
                                                                                                                </label>
                                                                                                            </div>
                                                                                                            <div>
                                                                                                                <h4 style="font-weight: 400;">Skip Servers With Low GPU's</h4>
                                                                                                                <label class="checkbox">
                                                                                                                    <input type="checkbox" id="skipSlowServers">Skip Slow Servers</input>
                                                                                                                </label>
                                                                                                            </div>
                                                                                                            <div>
                                                                                                                <h4 style="font-weight: 400;">Preview Servers</h4>
                                                                                                                <label class="checkbox">
                                                                                                                    <input type="checkbox" id="showServers">Server List</input>
                                                                                                                </label>
                                                                                                            </div>
                                                                                                            <div id="serverList" style="display: flex;justify-content: space-evenly;flex-wrap: wrap;align-content: stretch;flex-direction: column;"></div>
                                                                                                        </div>
                                                                                                        <div class="line"></div>
                                                                                                    <div style="display: flex;gap: calc(1.5vh* var(--scale-factor-h));">
                                                                                                        <button class="wide" id="startProcessBtn">Start Process</button>
                                                                                                        <button class="wide" id="cancellProcessBtn" >Cancel Process</button>
                                                                                                    </div>
                                                                                                </div>
                                                                                            </div>
                                                                                        </div>
                                                                                    </div>
                                                                                    <div class="background-container" style="display: flex;flex-direction: column;align-items: stretch;">
                                                                                        <div style="display: flex; gap: calc((1vh* var(--scale-factor-h) + 2vw / 2 * var(--scale-factor-w)));height: 100%;">
                                                                                            <div class="background-dot-container">
                                                                                                <div class="background-dot-container-content">
                                                                                                    <div class="outputs"></div>
                                                                                                    <div style="display: flex;justify-content: space-around;gap: calc(1.5vh* var(--scale-factor-h));">
                                                                                                        <button class="wide" id="downloadOutput">Download</button>
                                                                                                        <button class="wide" id="viewOutput">View</button>
                                                                                                    </div>
                                                                                                </div>
                                                                                            </div>
                                                                                        </div>
                                                                                    </div>
                                                                                </div>
                                                                                `);
            }

            loadPageContent(setUser, retrieveImageFromURL, getUserIpAddress, ensureUniqueId, fetchServerAddress, getFirebaseModules, getDocSnapshot, getScreenMode, getCurrentMain, updateContent, createPages, setNavbar, setSidebar, showSidebar, removeSidebar, getSidebarActive, moveMains, setupMainSize, loadScrollingAndMain, showZoomIndicator, setScaleFactors, clamp, setAuthentication, updateMainContent, savePageState);

            const mainContainers = document.querySelectorAll('.main-container');
            mainContainers.forEach((mainContainer, id) => {
                mainContainer.style.justifyContent = 'flex-start';
            });

            window.addEventListener('beforeunload', () => { savePageState(); });
            window.addEventListener('pagehide', () => { savePageState(); });

            document.addEventListener('click', () => { savePageState(); });
            document.addEventListener('touchend', () => { savePageState(); });

            function setMaxWidth() {
                const backgroundDotContainer = document.querySelector('.background-dot-container-content');
                const multibox = document.querySelector('.multibox');
                const multiboxText = document.querySelectorAll('.multibox-text');
                const arrowDwn = document.querySelector('.arrow-dwn');

                if (backgroundDotContainer && multibox && multiboxText && arrowDwn) {
                    const containerWidth = backgroundDotContainer.offsetWidth;
                    const containerStyle = getComputedStyle(backgroundDotContainer);
                    const multiboxStyle = getComputedStyle(multibox);
                    const arrowDwnStyle = getComputedStyle(arrowDwn);

                    const paddingLeft = parseFloat(multiboxStyle.paddingLeft) + parseFloat(containerStyle.paddingLeft) * 2;
                    const paddingRight = parseFloat(multiboxStyle.paddingRight) + parseFloat(containerStyle.paddingRight);
                    const arrowWidth = parseFloat(arrowDwnStyle.width);
                    const maxWidth = containerWidth - paddingLeft - paddingRight - arrowWidth;
                    multiboxText.forEach(text => { text.style.maxWidth = `${maxWidth - 2}px`; });
                }
            }

            function getSelectedInputId(checkboxes) {
                for (let checkbox of checkboxes) {
                    if (checkbox.checked) {
                        return checkbox.id;
                    }
                }

                return null;
            }

            let downloadFile = false;
            let maximumAllowedFrames = 36000;
            let oldMaximumAllowedFrames = null;

            function updateFrameLimit(checkbox) {
                oldMaximumAllowedFrames = maximumAllowedFrames;
                maximumAllowedFrames = 36000;

                const enhancers = [
                    document.getElementById('smooth_face_enhancer'),
                    document.getElementById('natural_face_enhancer_512'),
                    document.getElementById('natural_face_enhancer_1024'),
                    document.getElementById('natural_face_enhancer_2048'),
                ];

                const enabledEnhancer = getSelectedInputId(enhancers);
                if (!enabledEnhancer)
                    maximumAllowedFrames *= 2;

                const pixelBoosters = [
                    document.getElementById('pixelBoost256x256'),
                    document.getElementById('pixelBoost512x512'),
                    document.getElementById('pixelBoost1024x1024')
                ];

                const enabledPixelBoost = getSelectedInputId(pixelBoosters);
                if (enabledPixelBoost)
                    maximumAllowedFrames /= parseInt(enabledPixelBoost.match(/\d+x\d+/)[0].split('x')[0], 10) / 128;

                if (!document.getElementById("enableEnhancedLandmarks").checked)
                    maximumAllowedFrames *= 1.1;

                if (!document.getElementById("enableEnhancedAnalyzer").checked)
                    maximumAllowedFrames *= 1.1;

                if (!document.getElementById("enableOccluder").checked)
                    maximumAllowedFrames *= 1.1;

                if (document.getElementById("rightRotation").checked)
                    maximumAllowedFrames /= 1.1;

                if (document.getElementById("invertedRotation").checked)
                    maximumAllowedFrames /= 1.1;

                if (document.getElementById("leftRotation").checked)
                    maximumAllowedFrames /= 1.1;

                const values = [
                    document.getElementById("skin").checked,
                    document.getElementById("eyebrow").checked,
                    document.getElementById("eye").checked,
                    document.getElementById("glasses").checked,
                    document.getElementById("nose").checked,
                    document.getElementById("mouth").checked,
                    document.getElementById("lip").checked
                ];

                const enableRegionsCheck = values.some(value => !value);
                if (enableRegionsCheck)
                    maximumAllowedFrames /= 1.1;

                const pageData = localStorage.getItem(pageName) || null;
                if (!pageData || !checkbox || oldMaximumAllowedFrames === maximumAllowedFrames)
                    return;

                const span = checkbox.nextElementSibling;
                const featureText = span ? span.textContent : '';

                const frameRate = 30;
                const totalMinutes = (maximumAllowedFrames / frameRate) / 60;
                const frameLimitMessage = `Frame limit is ${Math.floor(maximumAllowedFrames)}: Allows you to upload a video up to ${totalMinutes.toFixed(2)} minutes at ${frameRate} FPS.`;

                showNotification(
                    frameLimitMessage,
                    `${featureText} ${checkbox.checked ? "Enabled" : "Disabled"}`,
                    'normal'
                );
            }

            const singleCreditForTotalFrameAmount = 120;

            const FILE_SIZE_LIMIT_MB = 500;
            const MAX_TASK_LIMIT = 10;
            const STATUS_OK = 200;
            const STATUS_NOTFOUND = 404;

            function loadPageState() {
                setMaxWidth();

                const pageData = localStorage.getItem(pageName) || null;
                if (pageData) {
                    const state = JSON.parse(pageData || '{}') || {};
                    document.getElementById('enableOccluder').checked = state.enableOccluder || false;
                    document.getElementById('enableEnhancedAnalyzer').checked = state.enableEnhancedAnalyzer || false;
                    document.getElementById('enableEnhancedLandmarks').checked = state.enableEnhancedLandmarks || false;
                    document.getElementById('removeBanner').checked = state.removeBanner || false;
                    document.getElementById('showServers').checked = state.showServers || false;
                    document.getElementById('skipSlowServers').checked = state.skipSlowServers || false;
                    document.getElementById('keepFPS').checked = state.keepFPS || false;
                    document.getElementById('fps-slider').value = state.fpsValue || 30;
                    document.getElementById('ageModifier').checked = state.ageModifier || false;
                    document.getElementById('age-modifier').value = state.ageModifierValue || 30;
                    document.getElementById('enhancerBlendValue').value = state.enhancerBlendValue || 30;
                    document.getElementById('fps-value').textContent = (state.fpsValue || 30) + ' FPS';

                    const navLinks = document.querySelectorAll('.nav-links .text');
                    navLinks.forEach(link => {
                        if (link.getAttribute('for') === state.activeLink) {
                            link.classList.add('active');
                            const targetSection = document.getElementById(state.activeLink);
                            if (targetSection) {
                                targetSection.style.display = 'flex';
                            }
                        }
                    });

                    const multiboxQuery = document.querySelectorAll('.multibox');
                    multiboxQuery.forEach((multibox, id) => {
                        const btnText = multibox.querySelector('.multibox-text');
                        const items = multibox.querySelectorAll('.item');

                        if (state.multiboxes && state.multiboxes[id]) {
                            btnText.innerText = state.multiboxes[id].text || '';

                            if (state.multiboxes[id].open) {
                                multibox.classList.add('open');
                                multibox.querySelector('.list-items').style.display = 'flex';
                            } else {
                                multibox.classList.remove('open');
                                multibox.querySelector('.list-items').style.display = 'none';
                            }

                            state.multiboxes[id].items.forEach((itemState, itemIndex) => {
                                if (itemIndex < items.length) {
                                    const checkbox = items[itemIndex].querySelector('input[type="checkbox"]');
                                    checkbox.checked = itemState.checked;
                                    items[itemIndex].classList.toggle('checked', checkbox.checked);
                                }
                            });
                        }
                    });

                    const comboboxQuery = document.querySelectorAll('.combobox');
                    comboboxQuery.forEach((combobox, id) => {
                        const btnText = combobox.querySelector('.combobox-text');
                        const items = combobox.querySelectorAll('.item');

                        if (state.comboboxes && state.comboboxes[id]) {
                            btnText.innerText = state.comboboxes[id].text || '';

                            if (state.comboboxes[id].open) {
                                combobox.classList.add('open');
                                combobox.querySelector('.list-items').style.display = 'flex';
                            } else {
                                combobox.classList.remove('open');
                                combobox.querySelector('.list-items').style.display = 'none';
                            }

                            state.comboboxes[id].items.forEach((itemState, itemIndex) => {
                                if (itemIndex < items.length) {
                                    const checkbox = items[itemIndex].querySelector('input[type="checkbox"]');
                                    checkbox.checked = itemState.checked;
                                    items[itemIndex].classList.toggle('checked', checkbox.checked);
                                }
                            });
                        }
                    });
                }
                else {
                    const checkboxIds = [
                        'skin',
                        'eyebrow',
                        'eye',
                        'glasses',
                        'nose',
                        'mouth',
                        'lip',
                        'enableEnhancedAnalyzer',
                        'enableEnhancedLandmarks',
                        'enableOccluder',
                        'natural_face_enhancer_1024',
                        'pixelBoost256x256',
                        'skipSlowServers',
                        'keepFPS'
                    ];

                    checkboxIds.forEach(id => {
                        const checkbox = document.getElementById(id);
                        checkbox.checked = true;
                        setTimeout(() => { checkbox.dispatchEvent(new Event('change')); }, 0);
                    });
                }
            }

            const databases = [
                { indexName: `outputDB-${pageName}`, objectStore: 'outputs' },
                { indexName: `faceDB-${pageName}`, objectStore: 'faces' },
                { indexName: `inputDB-${pageName}`, objectStore: 'inputs' }
            ];

            async function saveCountIndex() {
                for (const dbConfig of databases) {
                    const db = await openDB(dbConfig.indexName, dbConfig.objectStore);
                    const photoCount = await countInDB(db, dbConfig.objectStore);
                    localStorage.setItem(`${dbConfig.objectStore}-count`, photoCount);
                }
            }

            let downloadCancelled = false;
            let abortController = null;

            function deleteDownloadData(id) {
                localStorage.removeItem(`downloadedBytes_${id}`);
                localStorage.removeItem(`totalBytes_${id}`);

                const activeDataContainer = document.querySelector(".outputs .data-container.active");
                const dataContainerActive = activeDataContainer ? activeDataContainer : null;
                const downloadOutput = document.getElementById('downloadOutput');
                if (downloadOutput) {
                    downloadOutput.classList.remove("important");
                    downloadOutput.textContent = "Download";
                    downloadOutput.disabled = !dataContainerActive;
                }

                const viewOutput = document.getElementById('viewOutput');
                if (viewOutput) {
                    viewOutput.classList.remove("important");
                    viewOutput.textContent = "View";
                    viewOutput.disabled = !dataContainerActive;
                }

                if (abortController)
                    abortController.abort();
            }

            let lastProgress = 0;
            const progressMap = {};

            const handleDownload = async ({ db, url, element, id, timestamp, active }) => {
                if (!(db && url && element && id && timestamp)) {
                    alert('No Output Selected');
                    return;
                }

                downloadCancelled = false;

                const processText = msg => setProcessText(element, msg);

                if (active && !element.classList.contains('active'))
                    element.classList.add('active');

                element.innerHTML = `<initial url="${url}" id="${id}" timestamp="${timestamp}" active="${active}"><div class="process-text">Downloading...</div><div class="delete-icon"></div></initial>`;
                element.querySelector('.delete-icon').addEventListener('click', async () => {
                    downloadCancelled = true;
                    await updateChunksInDB(db, url, []);
                    deleteDownloadData(id);
                });

                if (!(id in progressMap)) {
                    progressMap[id] = 0;
                }

                lastProgress = progressMap[id];

                let isMobile = null;

                const activeDataContainer = document.querySelector(".outputs .data-container.active");
                const dataContainerActive = activeDataContainer ? activeDataContainer : null;
                const downloadOutput = document.getElementById('downloadOutput');
                if (downloadOutput) {
                    downloadOutput.textContent = "Pause";
                    downloadOutput.disabled = !dataContainerActive;
                }

                const viewOutput = document.getElementById('viewOutput');
                if (viewOutput) {
                    viewOutput.textContent = "View";

                    isMobile = iosMobileCheck();
                    if (!isMobile) {
                        viewOutput.textContent = "Fetch";
                        viewOutput.classList.add("important");
                        viewOutput.disabled = !dataContainerActive;
                    }
                }

                abortController = new AbortController();
                const { signal } = abortController;

                let downloadedBytes = parseInt(localStorage.getItem(`downloadedBytes_${id}`)) || 0;
                let totalBytes = parseInt(localStorage.getItem(`totalBytes_${id}`)) || 0;

                const previousData = await getFromDB(db);
                const entry = previousData.find(item => parseInt(item.id) === parseInt(id));
                const chunks = entry ? entry.chunks : [];

                while (!downloadCancelled) {
                    try {
                        const headers = downloadedBytes ? { 'Range': `bytes=${downloadedBytes}-` } : {};
                        const res = await fetch(url, { headers, signal });

                        if (![200, 206, 416].includes(res.status)) {
                            await updateChunksInDB(db, url, []);
                            deleteDownloadData(id);
                            throw new Error('Server does not support resumable downloads.');
                        }

                        const contentLength = res.headers.get('Content-Range')?.split('/')[1] || res.headers.get('Content-Length');
                        totalBytes ||= parseInt(contentLength);
                        localStorage.setItem(`totalBytes_${id}`, totalBytes);

                        const reader = res.body.getReader();
                        const contentType = res.headers.get('Content-Type');
                        let lastSavedProgress = 0;

                        while (!downloadCancelled) {
                            const { done, value } = await reader.read();
                            if (done) break;

                            downloadedBytes += value.length;
                            chunks.push(value);

                            if (viewOutput && isMobile) {
                                if (viewOutput.textContent !== "View")
                                    viewOutput.textContent = "View";

                                if (!viewOutput.disabled)
                                    viewOutput.disabled = true;
                            }

                            lastProgress = (downloadedBytes / totalBytes) * 100;
                            if (Math.floor(lastProgress) % 5 === 0 && Math.floor(lastProgress) > lastSavedProgress) {
                                await updateChunksInDB(db, url, chunks);
                                localStorage.setItem(`downloadedBytes_${id}`, downloadedBytes);
                                lastSavedProgress = Math.floor(lastProgress);
                                progressMap[id] = lastProgress; // Store progress for this ID
                            }
                            processText(`Downloaded: ${lastProgress.toFixed(0)}%`);
                        }

                        if (downloadCancelled) return;

                        const blob = new Blob(chunks.map(chunk => new Uint8Array(chunk)), { type: contentType });
                        const blobUrl = URL.createObjectURL(blob);

                        if (Math.abs(blob.size - totalBytes) > totalBytes * 0.01) {
                            alert(`Warning: The downloaded file size (${blob.size} bytes) differs significantly from expected size (${totalBytes} bytes).`);
                            await updateChunksInDB(db, url, []);
                            deleteDownloadData(id);
                            break;
                        }

                        if (active && !element.classList.contains('active'))
                            element.classList.add('active');

                        const isVideo = url.slice(-1) === '0';
                        element.innerHTML = isVideo
                            ? `<video url="${url}" id="${id}" timestamp="${timestamp}" active="${active}" playsinline preload="auto" disablePictureInPicture loop muted autoplay><source src="${blobUrl}" type="${contentType}">Your browser does not support the video tag.</video><div class="delete-icon"></div>`
                            : `<img url="${url}" id="${id}" timestamp="${timestamp}" active="${active}" src="${blobUrl}" alt="Uploaded Photo"/><div class="delete-icon"></div>`;

                        const activeContainers = document.querySelectorAll('.outputs .data-container.active');
                        if (activeContainers.length > 0) {
                            for (const container of activeContainers) {
                                container.classList.remove('active');
                                const element = container.querySelector('img, video, initial');
                                const id = parseInt(element.getAttribute('id'), 10);
                                if (id) {
                                    await updateActiveState(db, id, false).catch(err => {
                                        alert(`Update failed for id ${id}:`, err);
                                    });
                                }
                            }
                        }

                        element.classList.add('active');
                        if (id) {
                            await updateActiveState(db, id, true).catch(err => {
                                alert(`Update failed for id ${id}: ${err}`);
                            });
                        }

                        if (blob.size === 0) {
                            alert('Warning: Media not displayable');
                            await updateChunksInDB(db, url, []);
                            deleteDownloadData(id);
                            break;
                        }

                        downloadCancelled = true;

                        await Promise.all([
                            updateInDB(db, url, blob),
                            //updateChunksInDB(db, url, []),
                            saveCountIndex()
                        ]);

                        deleteDownloadData(id);
                        fetchableServerAddresses = (await fetchServerAddresses(getDocsSnapshot('servers'))).reverse();
                        return;
                    } catch (error) {
                        if (error.name === 'AbortError') {
                            processText(`Paused`);
                            return;
                        }

                        processText(`Error: ${error.message}. Retrying...`);
                    }
                }
            };

            window.addEventListener('beforeunload', async () => { await saveCountIndex(); });
            window.addEventListener('pagehide', async () => { await saveCountIndex(); });

            document.addEventListener('click', async () => { await saveCountIndex(); });
            document.addEventListener('touchend', async () => { await saveCountIndex(); });

            const handleDelete = async (dbName, storeName, parent) => {
                try {
                    const element = parent.querySelector('img, video, initial');
                    const domIndex = parseInt(element.getAttribute('id'), 10);
                    const db = await openDB(dbName, storeName);
                    const items = await getFromDB(db);

                    let itemToDelete = items.find(item => item.id === domIndex);

                    if (!itemToDelete) {
                        const domTimestamp = parseInt(element.getAttribute('timestamp'), 10);
                        itemToDelete = items.find(item => item.timestamp === domTimestamp);
                    }

                    if (itemToDelete) {
                        await deleteFromDB(db, itemToDelete.id, saveCountIndex);
                        parent.remove();
                    } else {
                        throw new Error('Item to delete not found.');
                    }
                } catch (error) {
                    alert('Error during delete operation: ' + error.message);
                }
            };

            const handleFileContainerEvents = async (event, dbName, storeName, container) => {
                const parent = event.target.closest('.data-container');
                if (!parent) return;

                if (event.target.classList.contains('delete-icon')) {
                    return await handleDelete(dbName, storeName, parent);
                }

                if (storeName === 'outputs') {
                    const viewOutput = document.getElementById('viewOutput');
                    if (viewOutput)
                        viewOutput.disabled = false;

                    const downloadOutput = document.getElementById('downloadOutput');
                    if (downloadOutput)
                        downloadOutput.disabled = false;
                }

                const db = openDB(dbName, storeName);

                for (const activeElement of container.querySelectorAll(".data-container.active")) {
                    activeElement.classList.remove("active");

                    const element = activeElement.querySelector('img, video, initial');
                    const domIndex = parseInt(element.getAttribute('id'), 10);

                    if (!isNaN(domIndex)) {
                        await updateActiveState(await db, domIndex, false);
                    } else {
                        alert(`Invalid id for active photo: ${activeElement}`);
                    }
                }

                const element = parent.querySelector('img, video, initial');
                const domIndex = parseInt(element.getAttribute('id'), 10);

                if (!isNaN(domIndex)) {
                    if (parent.classList.contains("active")) {
                        parent.classList.remove("active");
                        await updateActiveState(await db, domIndex, false);
                    } else {
                        parent.classList.add("active");
                        await updateActiveState(await db, domIndex, true);
                    }
                } else {
                    alert(`The provided ID for the parent photo "${parent}" is invalid. Please check the ID and try again.`);
                }
            };

            const handleUpload = async (event, dataBaseIndexName, dataBaseObjectStoreName) => {
                try {
                    if (!window.indexedDB) {
                        alert('Your browser does not support IndexedDB.');
                        return;
                    }

                    const db = await openDB(dataBaseIndexName, dataBaseObjectStoreName).catch((error) => {
                        if (error.name === 'QuotaExceededError') {
                            alert('Storage limit exceeded. Please free up space or clear cache.');
                        } else if (error.name === 'SecurityError') {
                            alert('Database access is restricted. Please check browser settings or disable private mode.');
                        } else {
                            alert(`Opening media database failed: ${error.message || error}`);
                        }
                        alert("Database opening error:", error);
                        return null;
                    });

                    if (!db) {
                        return;
                    }

                    const files = Array.from(event.target.files);
                    const mediaContainer = document.querySelector(`.${dataBaseObjectStoreName}`);
                    const fragment = document.createDocumentFragment();
                    const newMedia = [];

                    const processFile = async (file) => {
                        return new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.onload = async (e) => {
                                try {
                                    const blob = new Blob([e.target.result], { type: file.type });
                                    const { id, timestamp } = await addToDB(db, blob, saveCountIndex);
                                    newMedia.push({ id, timestamp, blob, isVideo: file.type.startsWith('video') });
                                    resolve();
                                } catch (error) {
                                    alert(`Processing media failed: ${error.message || error}`);
                                    reject(`Processing media failed: ${error.message}`);
                                }
                            };
                            reader.readAsArrayBuffer(file);
                        });
                    };

                    await Promise.all(files.map(processFile));

                    const activeContainers = mediaContainer.querySelectorAll('.data-container.active');
                    if (activeContainers.length > 0) {
                        for (const container of activeContainers) {
                            container.classList.remove('active');
                            const element = container.querySelector('img, video, initial');
                            const id = parseInt(element.getAttribute('id'), 10);
                            if (id) {
                                await updateActiveState(db, id, false).catch(err => {
                                    alert(`Update failed for id ${id}:`, err);
                                });
                            }
                        }
                    }

                    newMedia.reverse();

                    for (const { id, timestamp, blob, isVideo } of newMedia) {
                        const input = document.createElement('div');
                        input.className = 'data-container';

                        const blobUrl = URL.createObjectURL(blob);
                        if (isVideo) {
                            input.innerHTML = `<video timestamp="${timestamp}" id="${id}" loop muted autoplay><source src="${blobUrl}" type="${blob.type}">Your browser does not support the video tag.</video><div class="delete-icon"></div>`;
                        } else {
                            input.innerHTML = `<img timestamp="${timestamp}" id="${id}" src="${blobUrl}" alt="Uploaded Photo"/><div class="delete-icon"></div>`;
                        }

                        fragment.appendChild(input);

                        if (id === newMedia[newMedia.length - 1].id) {
                            input.classList.add('active');
                            if (id) {
                                await updateActiveState(db, id, true).catch(err => {
                                    alert(`Update failed for id ${id}: ${err}`);
                                });
                            }
                        }
                    }

                    mediaContainer.insertBefore(fragment, mediaContainer.firstChild);
                    localStorage.setItem(`${dataBaseObjectStoreName}-count`, await countInDB(db));
                } catch (error) {
                    alert(`Opening media database failed: ${error.message || error}`);
                }
            };

            const setupFileUpload = ({ buttonId, inputId, dataBaseIndexName, dataBaseObjectStoreName, changeHandler }) => {
                const input = document.getElementById(inputId);
                document.getElementById(buttonId).addEventListener('click', () => input.click());
                input.addEventListener('change', async (event) => {
                    await changeHandler(event, dataBaseIndexName, dataBaseObjectStoreName);
                });
            };

            const fileUploads = [
                { buttonId: 'circular-button-face-upload', inputId: 'face-upload', dataBaseIndexName: `faceDB-${pageName}`, dataBaseObjectStoreName: 'faces' },
                { buttonId: 'circular-button-input-upload', inputId: 'input-upload', dataBaseIndexName: `inputDB-${pageName}`, dataBaseObjectStoreName: 'inputs' }
            ];

            async function setClientStatus(message) {
                const outputs = document.querySelector('.outputs');
                if (outputs) {
                    outputs.firstChild.querySelector('.process-text').textContent = message;
                }
            }

            const setProcessText = (element, message) => {
                const processTextElement = element.querySelector('.process-text');
                if (processTextElement)
                    processTextElement.textContent = message;
            };


            function findServerWithUserRequest(results, userId) {
                return results.find(serverData => serverData.requestQueue?.includes(userId));
            }

            function handleUserRequest(serverData, userId) {
                const { processingAmount, remainingTime, elapsedTime, requestQueue } = serverData;
                const userQueueIndex = requestQueue.indexOf(userId);

                if (userQueueIndex === 0) {
                    updateClientStatus(processingAmount, remainingTime, elapsedTime);
                } else {
                    setClientStatus(`Queue ${userQueueIndex}...`);
                }

                if (downloadFile)
                    return;

                downloadFile = true;
            }

            function updateClientStatus(processingAmount, remainingTime, elapsedTime) {
                const statusMessage = processingAmount > 0
                    ? `%${processingAmount} | Remaining/Elapsed: ${remainingTime}/${elapsedTime}`
                    : 'Processing...';
                setClientStatus(statusMessage);
            }

            async function handleDownloadFileIfNeeded() {
                if (!downloadFile) return;
                downloadFile = false;

                const db = await openDB(`outputDB-${pageName}`, 'outputs');
                const outputs = (await getFromDB(db)).reverse();
                const lastOutput = outputs[outputs.length - 1];
                const data = await fetchProcessState(lastOutput.url);

                setClientStatus(data.server);
                showNotification(`Request ${data.status} With Status ${data.server}.`, 'Fetch Information', 'default');

                if (data.status === 'completed') {
                    setCurrentUserDoc(getDocSnapshot);
                    await handleLastOutputDownload(lastOutput);
                }
            }

            async function handleLastOutputDownload(lastOutput) {
                const blobIsEmpty = !lastOutput.blob || Object.entries(lastOutput.blob).length === 0;
                if (blobIsEmpty) {
                    const selectedOutputInfo = {
                        db: await openDB(`outputDB-${pageName}`, 'outputs'),
                        url: lastOutput.url,
                        timestamp: lastOutput.timestamp,
                        element: document.querySelector('.outputs').firstChild,
                        id: lastOutput.id,
                        active: lastOutput.active,
                    };

                    await handleDownload(selectedOutputInfo);
                }
            }

            let serverListContainer = document.getElementById('serverList');
            let fetchableServerAddresses = null;

            async function checkServerStatus() {
                serverListContainer = serverListContainer || document.getElementById('serverList');

                if (!fetchableServerAddresses) {
                    try {
                        fetchableServerAddresses = (await fetchServerAddresses(getDocsSnapshot('servers'))).reverse()
                    } catch (error) {
                        alert(`Error fetching server addresses: ${error.message}`);
                        return;
                    }
                }

                if (!fetchableServerAddresses)
                    return;

                const serverPromises = fetchableServerAddresses.map(async (server) => {
                    const response = await fetch(`${server}/get-online`);
                    if (response.status !== STATUS_OK)
                        return { queueAmount: Infinity };

                    const data = await response.json();
                    return {
                        queueAmount: data.server,
                        remainingTime: data.remainingTime,
                        elapsedTime: data.elapsedTime,
                        frameCount: data.frameCount,
                        totalFrames: data.totalFrames,
                        requestQueue: data.requestQueue,
                        uniqueId: data.uniqueId,
                        processingAmount: data.processingAmount,
                        SERVER_1: data.SERVER_1,
                    };
                });

                const results = await Promise.all(serverPromises);
                serverListContainer.innerHTML = '';

                const onlineServers = results.filter(serverData => serverData.queueAmount !== Infinity);
                if (onlineServers.length) {
                    onlineServers.forEach((serverData, serverIndex) => {
                        const listItem = document.createElement('div');
                        const newTime = calculateNewTime(serverData.remainingTime, serverData.queueAmount);
                        listItem.innerHTML = `<p>Server ${serverIndex + 1} (${serverData.SERVER_1}) - Queue: ${serverData.queueAmount === Infinity ? "Offline" : serverData.queueAmount} - ${serverData.frameCount || 0}/${serverData.totalFrames || 0} (%${serverData.processingAmount || 0}) - ${newTime}</p>`;
                        serverListContainer.appendChild(listItem);
                    });
                } else {
                    //if (!displayedError)
                    //alert('No servers are currently online.');
                    //else
                    //alert('No servers are currently online.');
                    //displayedError = true;
                }

                if (!userData?.uid) {
                    return;
                }

                const serverWithUserRequest = findServerWithUserRequest(results, userData.uid);
                if (serverWithUserRequest) {
                    handleUserRequest(serverWithUserRequest, userData.uid);
                } else {
                    startProcessBtn.disabled = false;
                    await handleDownloadFileIfNeeded();
                }
            }

            checkServerStatus();

            setInterval(checkServerStatus, 1000);

            function calculateNewTime(remainingTime, queueAmount) {
                if (!remainingTime) {
                    return '00:00';
                }
                const timeAdd = Math.max(0, (queueAmount - 1) * 10);
                const [hours, minutes] = remainingTime.split(':').map(Number);
                const currentDate = new Date();
                currentDate.setHours(hours);
                currentDate.setMinutes(minutes + timeAdd);
                const newHours = ('0' + currentDate.getHours()).slice(-2);
                const newMinutes = ('0' + currentDate.getMinutes()).slice(-2);
                const newTime = `${newHours}:${newMinutes}`;
                return newTime;
            }

            const cleanSiteData = async (automatic = false) => {
                try {
                    const confirmationMessage = !automatic
                        ? "Are you sure you want to delete local data, caches, and cookies?"
                        : "We need to clean cookies, caches, and local data for the new update. You don't need to confirm if you have data to download. After accepting, the data will be deleted, but the site will continue to function normally.";

                    const confirmed = confirm(confirmationMessage);
                    if (!confirmed) {
                        return;
                    }

                    location.reload(false);
                    const cacheBuster = new Date().getTime();
                    window.location.href = window.location.pathname + `?cb=${cacheBuster}`;
                } catch (error) {
                    alert("Error cleaning site data:", error);
                }
            };

            async function loadPage() {
                const removeDataButton = document.getElementById('removeData');
                if (removeDataButton)
                    removeDataButton.addEventListener('click', () => cleanSiteData(false));

                const facialCheckboxes = document.getElementById('facialCheckboxes');
                if (facialCheckboxes)
                    facialCheckboxes.style.flexDirection = getScreenMode() === ScreenMode.PC ? 'row' : 'column';

                const showServers = document.getElementById('showServers');
                serverListContainer = document.getElementById('serverList');
                serverListContainer.style.display = showServers.checked ? 'block' : 'none';

                showServers.addEventListener('click', async () => {
                    serverListContainer.style.display = showServers.checked ? 'block' : 'none';
                });

                databases.forEach(db => initDB(db.indexName, db.objectStore, handleDownload));

                document.querySelector('.inputs').addEventListener('click', async function (event) {
                    await handleFileContainerEvents(event, `inputDB-${pageName}`, 'inputs', document.querySelector('.inputs'));
                });

                document.querySelector('.faces').addEventListener('click', async function (event) {
                    await handleFileContainerEvents(event, `faceDB-${pageName}`, 'faces', document.querySelector('.faces'));
                });

                document.querySelector('.outputs').addEventListener('click', async function (event) {
                    await handleFileContainerEvents(event, `outputDB-${pageName}`, 'outputs', document.querySelector('.outputs'));
                });

                document.querySelectorAll('.question-mark').forEach(questionMark => {
                    questionMark.addEventListener('click', (event) => {
                        event.stopPropagation();
                    });
                });

                fileUploads.forEach(config => setupFileUpload({ ...config, changeHandler: handleUpload }));

                const navLinks = document.querySelectorAll('.nav-links .text');
                const sections = document.querySelectorAll('.section');

                navLinks.forEach(link => {
                    link.addEventListener('click', function () {
                        const active = this.classList.contains('active');

                        navLinks.forEach(link => link.classList.remove('active'));
                        sections.forEach(section => section.style.display = 'none');

                        if (!active) {
                            this.classList.add('active');

                            const targetId = this.getAttribute('for');
                            const targetSection = document.getElementById(targetId);
                            if (targetSection) {
                                targetSection.style.display = 'flex';
                            }
                        }
                    });
                });

                const multiboxes = document.querySelectorAll(".multibox");
                multiboxes.forEach(multibox => {
                    const selectBtn = multibox;
                    const items = multibox.querySelectorAll(".item");
                    const tooltip = multibox.querySelector(".tooltip");
                    const btnText = multibox.querySelector(".multibox-text");
                    const listItems = multibox.querySelector(".list-items");

                    selectBtn.addEventListener("click", (event) => {
                        event.stopPropagation();
                        multiboxes.forEach(box => {
                            if (box !== selectBtn) {
                                box.classList.remove("open");
                                box.querySelector(".list-items").style.display = "none";
                            }
                        });

                        selectBtn.classList.toggle("open");
                        listItems.style.display = selectBtn.classList.contains("open") ? "flex" : "none";
                    });

                    items.forEach(item => {
                        const checkbox = item.querySelector('input[type="checkbox"]');
                        const checkedItems = multibox.querySelectorAll(".item.checked input[type='checkbox']");
                        const selectedNames = Array.from(checkedItems).map(checkbox => {
                            const label = checkbox.parentElement.querySelector('span');
                            return label ? label.textContent.trim() : '';
                        }).filter(name => name !== '');

                        btnText.innerText = selectedNames.length > 0 ? selectedNames.join(', ') : btnText.getAttribute("title");

                        checkbox.addEventListener("change", () => {
                            item.classList.toggle("checked", checkbox.checked);

                            const checkedItems = multibox.querySelectorAll(".item.checked input[type='checkbox']");
                            const selectedNames = Array.from(checkedItems).map(checkbox => {
                                const label = checkbox.parentElement.querySelector('span');
                                return label ? label.textContent.trim() : '';
                            }).filter(name => name !== '');

                            btnText.innerText = selectedNames.length > 0 ? selectedNames.join(', ') : btnText.getAttribute("title");
                        });
                    });

                    listItems.addEventListener("mouseenter", () => {
                        tooltip.style.display = "none";
                    });

                    listItems.addEventListener("mouseleave", () => {
                        tooltip.style.display = "flex";
                    });
                });

                document.addEventListener("click", () => {
                    multiboxes.forEach(box => {
                        box.classList.remove("open");
                        box.querySelector(".list-items").style.display = "none";
                    });
                });

                const comboboxes = document.querySelectorAll(".combobox");

                comboboxes.forEach(combobox => {
                    const btnText = combobox.querySelector(".combobox-text");
                    const tooltip = combobox.querySelector(".tooltip");
                    const defaultTitle = btnText.getAttribute("title");
                    btnText.innerText = defaultTitle;

                    const listItems = combobox.querySelector(".list-items");
                    const selectBtn = combobox;

                    const sliderInput = combobox.querySelector('input[type="range"]');
                    if (sliderInput) {
                        sliderInput.addEventListener("click", (event) => {
                            event.stopPropagation();
                        });
                    }

                    selectBtn.addEventListener("click", (event) => {
                        event.stopPropagation();

                        comboboxes.forEach(cbx => {
                            if (cbx !== combobox) {
                                const otherListItems = cbx.querySelector(".list-items");
                                otherListItems.style.display = "none";
                                cbx.classList.remove("open");
                            }
                        });

                        selectBtn.classList.toggle("open");
                        listItems.style.display = selectBtn.classList.contains("open") ? "flex" : "none";
                    });

                    const items = combobox.querySelectorAll(".item");
                    items.forEach(item => {
                        const checkbox = item.querySelector('input[type="checkbox"]');
                        if (checkbox.checked) {
                            items.forEach(i => {
                                const cb = i.querySelector('input[type="checkbox"]');
                                cb.checked = false;
                                i.classList.remove("checked");
                            });

                            if (sliderInput)
                                sliderInput.parentElement.style.display = 'flex';
                            checkbox.checked = true;
                            item.classList.add("checked");
                            btnText.innerText = defaultTitle + ": " + checkbox.parentElement.querySelector('span').textContent.trim();
                        } else {
                            const anyChecked = [...items].some(i => i.querySelector('input[type="checkbox"]').checked);
                            if (!anyChecked) {
                                btnText.innerText = defaultTitle + ": " + "Disabled";
                                if (sliderInput)
                                    sliderInput.parentElement.style.display = 'none';
                            }
                            item.classList.remove("checked");
                        }

                        checkbox.addEventListener("change", () => {
                            if (checkbox.checked) {
                                items.forEach(i => {
                                    const cb = i.querySelector('input[type="checkbox"]');
                                    cb.checked = false;
                                    i.classList.remove("checked");
                                });

                                if (sliderInput)
                                    sliderInput.parentElement.style.display = 'flex';
                                checkbox.checked = true;
                                item.classList.add("checked");
                                btnText.innerText = defaultTitle + ": " + checkbox.parentElement.querySelector('span').textContent.trim();
                            } else {
                                const anyChecked = [...items].some(i => i.querySelector('input[type="checkbox"]').checked);
                                if (!anyChecked) {
                                    btnText.innerText = defaultTitle + ": " + "Disabled";
                                    if (sliderInput)
                                        sliderInput.parentElement.style.display = 'none';
                                }
                                item.classList.remove("checked");
                            }
                        });
                    });

                    listItems.addEventListener("mouseenter", () => {
                        tooltip.style.display = "none";
                    });

                    listItems.addEventListener("mouseleave", () => {
                        tooltip.style.display = "flex";
                    });
                });

                document.addEventListener("click", () => {
                    comboboxes.forEach(combobox => {
                        const listItems = combobox.querySelector(".list-items");
                        listItems.style.display = "none";
                        combobox.classList.remove("open");
                    });
                });

                const keepFPS = document.getElementById('keepFPS');
                const keepFPSContainer = document.getElementById('keepFPSContainer');
                const fpsSlider = document.getElementById('fps-slider');
                const fpsValue = document.getElementById('fps-value');
                keepFPSContainer.style.display = !keepFPS.checked ? 'flex' : 'none';
                keepFPS.addEventListener('change', () => {
                    keepFPSContainer.style.display = !keepFPS.checked ? 'flex' : 'none';
                });

                fpsValue.innerText = fpsSlider.value + " FPS";

                fpsSlider.addEventListener('input', () => {
                    fpsValue.innerText = fpsSlider.value + " FPS";
                });

                const ageModifier = document.getElementById('ageModifier');
                if (ageModifier) {
                    const ageModifierContainer = document.getElementById('ageModifierContainer');
                    if (ageModifierContainer)
                        ageModifierContainer.style.display = ageModifier.checked ? 'flex' : 'none';

                    ageModifier.addEventListener('change', () => {
                        if (ageModifierContainer)
                            ageModifierContainer.style.display = ageModifier.checked ? 'flex' : 'none';
                    });
                }

                const ageModifierSlider = document.getElementById('age-modifier');
                const ageModifierValue = document.getElementById('age-modifier-value');

                if (ageModifierValue && ageModifierSlider) {
                    ageModifierValue.innerText = ageModifierSlider.value + "%";

                    ageModifierSlider.addEventListener('input', () => {
                        ageModifierValue.innerText = ageModifierSlider.value + "%";
                    });
                }

                const enhancerBlendValueSlider = document.getElementById('enhancerBlendValue');
                const enhancerBlendDisplayValue = document.getElementById('enhancerBlendDisplayValue');

                if (enhancerBlendDisplayValue && enhancerBlendValueSlider) {
                    enhancerBlendDisplayValue.innerText = parseInt(enhancerBlendValueSlider.value, 10) < 25 ? 'Auto' : enhancerBlendValueSlider.value + "%";

                    enhancerBlendValueSlider.addEventListener('input', () => {
                        enhancerBlendDisplayValue.innerText = parseInt(enhancerBlendValueSlider.value, 10) < 25 ? 'Auto' : enhancerBlendValueSlider.value + "%";
                    });
                }

                const startProcessBtn = document.getElementById('startProcessBtn');
                const cancellProcessBtn = document.getElementById('cancellProcessBtn');

                async function startProcess() {
                    startProcessBtn.disabled = true;

                    try {
                        if (!userData || !userData.uid) {
                            const openSignInContainer = document.getElementById('openSignInContainer');
                            if (openSignInContainer)
                                openSignInContainer.click();
                            startProcessBtn.disabled = false;
                            return;
                        }

                        const dataContainer = document.createElement('div');
                        dataContainer.className = 'data-container';

                        const processText = document.createElement('div');
                        processText.className = 'process-text';
                        dataContainer.appendChild(processText);

                        const outputs = document.querySelector('.outputs');
                        outputs.style.display = 'flex';
                        outputs.insertBefore(dataContainer, outputs.firstChild);

                        if (!userData.emailVerified) {
                            setClientStatus('Verify Your Email');
                            startProcessBtn.disabled = false;
                            return;
                        }

                        userDoc = getCachedDynamicUserDoc();

                        const activeVideoInput = document.querySelector(".inputs .data-container.active video");
                        const activePhotoInput = document.querySelector(".inputs .data-container.active img");
                        const activePhoto = document.querySelector(".faces .data-container.active img");

                        if (!activeVideoInput && !activePhotoInput) {
                            setClientStatus(`Click Your Uploaded Input Above`);
                            startProcessBtn.disabled = false;
                            return;
                        }

                        if (!activePhoto) {
                            setClientStatus(`Click Your Uploaded Face Above`);
                            startProcessBtn.disabled = false;
                            return;
                        }

                        let videoDurationTotalFrames = 0;

                        if (activeVideoInput) {
                            const assumedFrameRate = !keepFPS.checked ? document.getElementById("fps-slider").value : 60;
                            videoDurationTotalFrames = Math.floor(activeVideoInput.duration * assumedFrameRate);
                            if (videoDurationTotalFrames <= 0) {
                                setClientStatus(`No Frame Detected`);
                                startProcessBtn.disabled = false;
                                return;
                            }

                            if (videoDurationTotalFrames > maximumAllowedFrames && !userDoc.admin) {
                                setClientStatus(`Exceeding Frame Limit | Lower the settings`);
                                showNotification(!keepFPS.checked ? 'If your video has less than 60 FPS, please specify by closing Keep FPS option.' : 'Lowering the settings will increase frame limit.', 'Warning - Exceeding Frame Limit', 'warning');
                                startProcessBtn.disabled = false;
                                return;
                            }
                        }

                        const removeBanner = document.getElementById("removeBanner");
                        const removeBannerStateMultiplier = removeBanner.checked ? 2 : 1;

                        let neededCredits = 0;

                        if (activeVideoInput) {
                            const resolutionMultiplier = Math.max(1, 1 + Math.floor((activeVideoInput.videoWidth + activeVideoInput.videoHeight - 2500) / 1000) * 0.5);
                            neededCredits = Math.floor(Math.max(1, videoDurationTotalFrames / singleCreditForTotalFrameAmount) * resolutionMultiplier * removeBannerStateMultiplier);
                        } else if (activePhotoInput) {
                            neededCredits = removeBannerStateMultiplier;
                        }

                        neededCredits = Math.max(1, neededCredits);
                        setClientStatus('Creating ID...');

                        const pixelBoosters = [
                            document.getElementById('pixelBoost256x256'),
                            document.getElementById('pixelBoost512x512'),
                            document.getElementById('pixelBoost1024x1024')
                        ];

                        let enabledPixelBoost = getSelectedInputId(pixelBoosters);
                        if (enabledPixelBoost)
                            enabledPixelBoost = enabledPixelBoost.match(/\d+x\d+/)[0];

                        if (!enabledPixelBoost)
                            enabledPixelBoost = '128x128';

                        async function getServerAddresses() {
                            return await fetchServerAddresses(getDocsSnapshot('servers'), enabledPixelBoost === '128x128' && (activePhotoInput || neededCredits < 1) || !document.getElementById('skipSlowServers').checked);
                        }

                        let [userIpAddress, browserUniqueId, serverAddresses] = await Promise.all([
                            getUserIpAddress(),
                            ensureUniqueId(),
                            getServerAddresses()
                        ]);

                        async function checkServerQueue(server) {
                            const response = await fetch(`${server}/get-online`);
                            if (response.status === STATUS_OK) {
                                const data = await response.json();
                                return data.server;
                            }

                            return Infinity;
                        }

                        const serverForSmallProcesses = "https://4090-1-DF.bodyswap.me";
                        const serverPromises = serverAddresses.map(server => checkServerQueue(server));
                        const results = await Promise.all(serverPromises);

                        if (neededCredits > 0 && neededCredits < 25 || videoDurationTotalFrames < 500) {
                            const primaryServerQueue = await checkServerQueue(serverForSmallProcesses);
                            const everyServerEmpty = results.every(queue => queue === 0);
                            const someServerNotEmpty = results.some(queue => queue === 0);
                            if (someServerNotEmpty && !everyServerEmpty && primaryServerQueue > 0 || primaryServerQueue >= MAX_TASK_LIMIT) {
                                const minQueueIndex = results.reduce((minIndex, queue, id, arr) => {
                                    return (queue < arr[minIndex] && queue >= 0) ? id : minIndex;
                                }, 0);
                                if (results[minQueueIndex] === Infinity) {
                                    startProcessBtn.disabled = false;
                                    setClientStatus('Offline');
                                    return;
                                }
                                fetchableServerAddresses = [serverAddresses[minQueueIndex]];
                            } else {
                                fetchableServerAddresses = [serverForSmallProcesses];
                            }
                        } else {
                            const id = fetchableServerAddresses.indexOf(serverForSmallProcesses);
                            if (id !== -1) {
                                fetchableServerAddresses.splice(id, 1);
                            }
                            const minQueueIndex = results.reduce((minIndex, queue, id, arr) => {
                                return (queue < arr[minIndex]) ? id : minIndex;
                            }, 0);
                            if (results[minQueueIndex] === Infinity) {
                                startProcessBtn.disabled = false;
                                setClientStatus('Offline');
                                return;
                            }
                            fetchableServerAddresses = [serverAddresses[minQueueIndex]];
                        }

                        const serverAddress = fetchableServerAddresses[0];
                        console.log(fetchableServerAddresses[0]);
                        setClientStatus(`Connecting`);

                        const processBlobToFile = async (blobUrl, fileName, fileType) => {
                            const response = await fetch(blobUrl);
                            const blob = await response.blob();
                            return new File([blob], fileName, { type: fileType });
                        };

                        const fileType = activeVideoInput ? 'video/mp4' : 'image/png';
                        const extension = activeVideoInput ? 'mp4' : 'png';
                        const timestamp = activeVideoInput?.getAttribute('timestamp') || activePhotoInput?.getAttribute('timestamp');
                        const id = activeVideoInput?.getAttribute('id') || activePhotoInput?.getAttribute('id');

                        if (!timestamp || !id) {
                            alert('Timestamp or id is missing. Cannot create input file name.');
                            return;
                        }

                        const inputFileName = `${timestamp}_${id}.${extension}`;
                        const inputFile = await processBlobToFile(activeVideoInput ? activeVideoInput.querySelector('source').src : activePhotoInput.src, inputFileName, fileType);
                        const faceFile = await processBlobToFile(activePhoto.src, 'image.png', 'image/png');

                        if ((faceFile.size + inputFile.size) / (1024 * 1024) > FILE_SIZE_LIMIT_MB) {
                            startProcessBtn.disabled = false;
                            setClientStatus(`Size exceeds ${FILE_SIZE_LIMIT_MB}MB limit`);
                            return;
                        }

                        let width = 0;
                        let height = 0;

                        if (activeVideoInput) {
                            activeVideoInput.addEventListener('loadedmetadata', function () {
                                width = activeVideoInput.videoWidth;
                                height = activeVideoInput.videoHeight;
                            });

                            if (activeVideoInput.readyState >= 1) {
                                width = activeVideoInput.videoWidth;
                                height = activeVideoInput.videoHeight;
                            }
                        } else if (activePhotoInput) {
                            const img = activePhotoInput;

                            img.onload = function () {
                                width = img.naturalWidth;
                                height = img.naturalHeight;
                            };

                            if (img.complete) {
                                img.onload();
                            }
                        }

                        const maxPixelCount = 1600 * 900;
                        const midPixelCount = 854 * 480;
                        const lowPixelCount = 426 * 240;

                        const calculateEnhancerBlendValue = () => {
                            const pixelCount = height * width;

                            if (pixelCount >= maxPixelCount) {
                                return 100;
                            } else if (pixelCount >= midPixelCount) {
                                return Math.round(
                                    50 + (50 * (pixelCount - midPixelCount)) / (maxPixelCount - midPixelCount)
                                );
                            } else if (pixelCount >= lowPixelCount) {
                                return Math.round(
                                    25 + (25 * (pixelCount - lowPixelCount)) / (midPixelCount - lowPixelCount)
                                );
                            }

                            return Math.round((25 * pixelCount) / lowPixelCount);
                        };

                        let enableEnhancer = false;
                        let enabledEnhancer = '';
                        let enhancerBlendValue = calculateEnhancerBlendValue();
                        if (enhancerBlendValue > 100 / 4) {
                            const enhancerOptions = ['smooth_face_enhancer', 'natural_face_enhancer_512', 'natural_face_enhancer_1024', 'natural_face_enhancer_2048'];
                            enabledEnhancer = enhancerOptions.find(id => {
                                const enhancer = document.getElementById(id);
                                return enhancer && enhancer.checked;
                            });

                            enableEnhancer = enabledEnhancer ? document.getElementById(enabledEnhancer).checked : false;
                        } else enhancerBlendValue = 0;

                        if (enhancerBlendValue > 0 && enabledEnhancer !== 'smooth_face_enhancer')
                            enhancerBlendValue *= 1.5;

                        enhancerBlendValue = clamp(enhancerBlendValue, 0, 100);

                        const userName = userDoc.username;
                        const userEmail = userDoc.email;
                        const processCount = userDoc.processCount || 0;

                        const uniqueId = `${userName}_${userEmail}_${processCount}_${neededCredits}_${activeVideoInput ? 0 : 1}`
                            .replace(/[^a-zA-Z0-9_-]/g, '_')
                            .replace(/\s/g, '');

                        const db = await openDB(`outputDB-${pageName}`, 'outputs');
                        const url = serverAddress + '/download-output/' + uniqueId;
                        const firstChild = outputs.firstChild;

                        if (firstChild && !firstChild.dataset.created) {
                            firstChild.dataset.created = true;
                            firstChild.innerHTML = `<div class="process-text">Indexing</div>`;

                            await addToDB(db, [null, url], saveCountIndex);

                            const data = await getFromDB(db);
                            const entry = data.find(item => item.url === url);

                            firstChild.innerHTML = `<initial url="${entry.url}" id="${entry.id}" timestamp="${entry.timestamp}"/></initial><div class="process-text">Indexing</div>`;
                        }

                        function fetchToServer(url, options, onProgress) {
                            if (typeof onProgress !== 'function') {
                                return fetch(url, options);
                            }

                            return new Promise((resolve, reject) => {
                                const xhr = new XMLHttpRequest();
                                xhr.open(options.method || 'GET', url);

                                xhr.upload.onprogress = (event) => {
                                    if (event.lengthComputable) {
                                        const progress = (event.loaded / event.total) * 100;
                                        onProgress(progress);
                                    }
                                };

                                xhr.onload = () => {
                                    if (xhr.status >= STATUS_OK && xhr.status < STATUS_NOTFOUND) {
                                        resolve(new Response(xhr.responseText, { status: xhr.status }));
                                    } else {
                                        reject(new Error(`Request failed with status ${xhr.status}`));
                                        setClientStatus(`Request failed with status ${xhr.status}`);
                                        showNotification(`Request failed with status ${xhr.status}. Try Again.`, 'Warning - Fetching Failed', 'warning');
                                    }
                                };

                                xhr.onerror = () => {
                                    reject(new Error('Request failed'));
                                    setClientStatus(`Request failed.`);
                                    showNotification(`Request failed with status ${xhr.status}. Try Again.`, 'Warning - Fetching Failed', 'warning');
                                };

                                for (const key in options.headers) {
                                    if (options.headers.hasOwnProperty(key)) {
                                        xhr.setRequestHeader(key, options.headers[key]);
                                    }
                                }

                                xhr.send(options.body);
                            });
                        }

                        const MB = 1024 * 1024;
                        const chunkSize = 25 * MB;
                        const totalSize = inputFile.size;
                        const maxChunkNumber = Math.ceil(totalSize / chunkSize);
                        const uploadedSizes = new Array(maxChunkNumber).fill(0);

                        async function fetchUploadedChunks(fileName) {
                            const response = await fetch(`${serverAddress}/uploaded-chunks?fileName=${fileName}`);
                            const uploadedChunks = await response.json();
                            return uploadedChunks;
                        }

                        const uploadedChunks = await fetchUploadedChunks(inputFile.name);

                        for (let chunkNumber = 0; chunkNumber < maxChunkNumber; chunkNumber++) {
                            if (uploadedChunks.includes(chunkNumber.toString())) {
                                continue;
                            }

                            let start = chunkNumber * chunkSize;
                            let end = Math.min(start + chunkSize, totalSize);

                            const formData = new FormData();
                            const chunk = inputFile.slice(start, end);
                            formData.append('videoChunk', chunk, `${inputFile.name}.part${chunkNumber}`);
                            formData.append('fileType', fileType);

                            await fetchToServer(`${serverAddress}/upload-chunk`, {
                                method: 'POST',
                                body: formData,
                            }, (progress) => {
                                const chunkUploadedSize = (progress / 100) * chunk.size;
                                uploadedSizes[chunkNumber] = chunkUploadedSize;
                                const uploadedSize = uploadedSizes.reduce((total, size) => total + size, 0);
                                const overallProgress = (uploadedSize / totalSize) * 100;
                                setClientStatus(`Upload (${chunkNumber + 1}/${maxChunkNumber}): ${overallProgress.toFixed(0)}%`);
                            });
                        }

                        setClientStatus('Configurating');

                        const formData = new FormData();
                        formData.append('face', faceFile);
                        formData.append('inputFileName', inputFile.name);
                        formData.append('userId', userData.uid);
                        formData.append('userIpAddress', userIpAddress);
                        formData.append('uniqueId', uniqueId);
                        formData.append('uniqueUserBrowserProcessId', browserUniqueId);
                        formData.append('enableBox', true);
                        formData.append('enableOccluder', document.getElementById("enableOccluder").checked);
                        formData.append('enableEnhancer', enableEnhancer);
                        formData.append('enabledEnhancer', enabledEnhancer);
                        formData.append('enhancerBlendValue', parseInt(document.getElementById('enhancerBlendValue').value, 10) < 25 ? parseInt(enhancerBlendValue, 10) : parseInt(document.getElementById('enhancerBlendValue').value, 10));
                        formData.append('enabledPixelBoost', enabledPixelBoost);
                        formData.append('removeBanner', removeBanner.checked);
                        formData.append('keepFPS', document.getElementById("keepFPS").checked);
                        formData.append('fpsValue', document.getElementById("fps-slider").value);
                        formData.append('ageModifier', Math.abs(document.getElementById("age-modifier").value) <= 5 ? null : document.getElementById("ageModifier").checked);
                        formData.append('ageModifierValue', Math.abs(document.getElementById("age-modifier").value) <= 5 ? null : parseInt(document.getElementById("age-modifier").value, 10));
                        formData.append('skin', document.getElementById("skin").checked);
                        formData.append('eyebrow', document.getElementById("eyebrow").checked);
                        formData.append('eye', document.getElementById("eye").checked);
                        formData.append('glasses', document.getElementById("glasses").checked);
                        formData.append('nose', document.getElementById("nose").checked);
                        formData.append('mouth', document.getElementById("mouth").checked);
                        formData.append('lip', document.getElementById("lip").checked);
                        formData.append('frontalRotation', document.getElementById("frontalRotation").checked);
                        formData.append('rightRotation', document.getElementById("rightRotation").checked);
                        formData.append('invertedRotation', document.getElementById("invertedRotation").checked);
                        formData.append('leftRotation', document.getElementById("leftRotation").checked);
                        formData.append('faceAnalyserAge', 'none');
                        formData.append('faceAnalyserGender', 'none');
                        formData.append('faceAnalyserOrder', 'none');
                        formData.append('enableEnhancedLandmarks', document.getElementById("enableEnhancedLandmarks").checked);
                        formData.append('enableEnhancedAnalyzer', document.getElementById("enableEnhancedAnalyzer").checked);
                        formData.append('imageSize', 'none');
                        formData.append('imageModel', 'none');

                        setClientStatus('Starting...');
                        fetch(`${serverAddress}/start-process`, {
                            method: 'POST',
                            body: formData,
                        })
                            .then(async response => {
                                if (response.status === STATUS_OK) {
                                    return response.json();
                                } else if (response.status === STATUS_NOTFOUND) {
                                    cancelProcess(false);
                                    setClientStatus('Offline');
                                    startProcessBtn.disabled = false;
                                } else {
                                    return response.json().then(data => {
                                        startProcessBtn.disabled = false;
                                        cancelProcess(false);
                                        throw new Error(data.server);
                                    });
                                }
                            })
                            .catch(error => {
                                startProcessBtn.disabled = false;
                                setClientStatus(error.message);
                                cancelProcess(false);
                            });
                    } catch (error) {
                        startProcessBtn.disabled = false;
                        setClientStatus(error.message);
                        cancelProcess(false);
                    }
                }

                startProcessBtn.addEventListener('click', async () => {
                    await startProcess();
                });

                function cancelProcess(showAlertion) {
                    return new Promise(async (resolve) => {
                        try {
                            await setCurrentUserDoc(getDocSnapshot); userDoc = getCachedDynamicUserDoc();

                            const userIsProcessing = userDoc.isProcessing;
                            const serverAddresses = await fetchServerAddresses(getDocsSnapshot('servers'));
                            const serverPromises = serverAddresses.map(server => {
                                return fetch(`${server}/get-online`).then(response => {
                                    if (response.status === STATUS_NOTFOUND)
                                        return { queueAmount: Infinity, remainingTime: 0, SERVER_1: "Unkown" };

                                    else if (response.status === STATUS_OK)
                                        return response.json();

                                    else return { queueAmount: Infinity, remainingTime: 0, SERVER_1: "Unkown" };
                                }).then(data => ({ queueAmount: data.server, faceDetectionError: data.faceDetectionError, videoUnsupportedTooLongError: data.videoUnsupportedTooLongError, remainingTime: data.remainingTime, elapsedTime: data.elapsedTime, frameCount: data.frameCount, totalFrames: data.totalFrames, requestQueue: data.requestQueue, uniqueId: data.uniqueId, processingAmount: data.processingAmount, SERVER_1: data.SERVER_1 })).catch(error => {
                                    return { queueAmount: Infinity, remainingTime: 0, SERVER_1: "Unkown" };
                                });
                            });

                            const results = await Promise.all(serverPromises);
                            const serverWithUserRequest = results.find(serverData => serverData.requestQueue && serverData.requestQueue.includes(userData.uid));

                            if (userIsProcessing || serverWithUserRequest) {
                                const cancelRequests = serverAddresses.map(async (serverAddress) => {
                                    try {
                                        const response = await fetch(`${serverAddress}/cancel-process`, {
                                            method: 'POST',
                                            headers: { 'Content-Type': 'application/json' },
                                            body: JSON.stringify({ userId: userData.uid }),
                                        });

                                        if (showAlertion) {
                                            if (response.ok) {
                                                startProcessBtn.disabled = false;
                                                setClientStatus(`Request got cancelled`);
                                            }
                                        }
                                    } catch (error) {
                                        console.error(`Error on server ${serverAddress}:`, error);
                                    }
                                });

                                await Promise.all(cancelRequests);
                            } else if (showAlertion)
                                alert('User is not processing. No cancellation request sent.');
                        } catch (error) {
                            console.error('Error checking processes:', error);
                        } finally {
                            resolve();
                        }
                    });
                }

                cancellProcessBtn.addEventListener('click', async () => {
                    await cancelProcess(true);
                });

                const downloadOutput = document.getElementById('downloadOutput');
                if (downloadOutput) {
                    const activeDataContainer = document.querySelector(".outputs .data-container.active");
                    if (!activeDataContainer)
                        downloadOutput.disabled = true;

                    downloadOutput.addEventListener('click', async () => {
                        const activeDataContainer = document.querySelector(".outputs .data-container.active");
                        const activeInput = activeDataContainer.querySelector('img, video, initial');

                        if (activeInput) {
                            if (downloadOutput.textContent === "Pause") {
                                if (abortController) {
                                    abortController.abort();
                                    downloadCancelled = true;
                                }

                                downloadOutput.textContent = "Resume";
                                downloadOutput.classList.add("important");
                                return;
                            }

                            if (downloadOutput.textContent === "Resume") {
                                const selectedOutputInfo = {
                                    db: await openDB(`outputDB-${pageName}`, 'outputs'),
                                    url: activeInput.getAttribute('url'),
                                    timestamp: parseInt(activeInput.getAttribute('timestamp')),
                                    element: activeInput.parentElement,
                                    id: parseInt(activeInput.getAttribute('id')),
                                    active: activeInput.getAttribute('active'),
                                };

                                return await handleDownload(selectedOutputInfo);
                            }

                            let blobUrl = '';
                            let fileName = 'output_';

                            if (activeInput) {
                                blobUrl = activeInput.tagName === 'VIDEO'
                                    ? activeInput.querySelector('source').src
                                    : activeInput.src;

                                const id = activeInput.getAttribute('id');
                                fileName += `${id}.${activeInput.tagName === 'VIDEO' ? 'mp4' : 'png'}`;

                                if (blobUrl) {
                                    if (window.showSaveFilePicker) {
                                        const fileHandle = await window.showSaveFilePicker({
                                            suggestedName: fileName,
                                            types: [{
                                                description: 'Video Files',
                                                accept: { 'video/mp4': ['.mp4'] }
                                            }, {
                                                description: 'Image Files',
                                                accept: { 'image/png': ['.png'] }
                                            }]
                                        });

                                        const writableStream = await fileHandle.createWritable();
                                        const response = await fetch(blobUrl);
                                        const blob = await response.blob();
                                        await writableStream.write(blob);
                                        await writableStream.close();
                                    }
                                    else if (navigator.share) {
                                        const response = await fetch(blobUrl);
                                        const blob = await response.blob();
                                        const fileToShare = new File([blob], fileName, { type: activeVideoInput ? 'video/mp4' : 'image/png' });
                                        await navigator.share({ title: fileName, files: [fileToShare] });
                                    }
                                    else {
                                        const a = document.createElement('a');
                                        a.href = blobUrl;
                                        a.download = fileName;
                                        document.body.appendChild(a);
                                        a.click();
                                        document.body.removeChild(a);
                                    }
                                }
                            }
                        }
                    });
                }

                const viewOutput = document.getElementById('viewOutput');
                if (viewOutput) {
                    const activeDataContainer = document.querySelector(".outputs .data-container.active");
                    if (!activeDataContainer)
                        viewOutput.disabled = true;

                    viewOutput.addEventListener('click', async () => {
                        const activeDataContainer = document.querySelector(".outputs .data-container.active");
                        const activeInput = activeDataContainer.querySelector('img, video, initial');

                        if (activeInput) {
                            if (viewOutput.textContent === 'Fetch') {
                                if (abortController) {
                                    abortController.abort();
                                    abortController = null;
                                    downloadOutput.textContent = "Resume";
                                    downloadCancelled = true;
                                }

                                return window.open(activeInput.getAttribute('url'), '_blank');
                            }

                            return window.open(activeInput.tagName === 'VIDEO' ? activeInput.querySelector('source').src : activeInput.src, '_blank');
                        }
                    });
                }

                updateFrameLimit(null);

                document.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                    checkbox.addEventListener("change", () => {
                        updateFrameLimit(checkbox);
                    });
                });
            }

            let previousScreenMode = null;

            async function sizeBasedElements() {
                setMaxWidth();
                const screenMode = getScreenMode();
                const shouldUpdate = previousScreenMode !== screenMode;
                previousScreenMode = screenMode;
                if (!shouldUpdate)
                    return;

                loadPageState();
                loadPage();
            }

            sizeBasedElements();

            window.addEventListener('resize', sizeBasedElements);
        });
    </script>
    <script defer>
        window.gtag = function () {
            window.dataLayer = window.dataLayer || [];
            window.dataLayer.push(arguments);
        };

        document.addEventListener('DOMContentLoaded', function () {
            setTimeout(function () {
                const gtagScript = document.createElement('script');
                gtagScript.src = 'https://www.googletagmanager.com/gtag/js?id=G-BFR70Q5VX1';
                gtagScript.async = true;
                document.head.appendChild(gtagScript);

                gtagScript.onload = function () {
                    gtag('js', new Date());
                    gtag('config', 'G-BFR70Q5VX1');
                };
            }, 500);
        });
    </script>
</body>
</html>
