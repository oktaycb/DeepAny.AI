

	<!DOCTYPE html>
	<html lang="en">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Swiper/4.5.0/css/swiper.min.css">

    <title>DeepInpaint | BodySwap.me (DeepAny.AI)</title>
    <meta name="title" content="BodySwap.me (DeepAny.AI) | DeepInpaint">
    <meta name="description" content="This is our inpainting page which allows you to remove or change the current input!..">
  
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://bodyswap.me">
    <meta property="og:title" content="BodySwap.me (DeepAny.AI) | DeepInpaint">
    <meta property="og:description" content="This is our inpainting page which allows you to remove or change the current input!..">
    <meta property="og:image" content="https://bodyswap.me/files/assets/meta/background-wide.png">
  
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://bodyswap.me">
    <meta property="twitter:title" content="BodySwap.me (DeepAny.AI) | DeepInpaint">
    <meta property="twitter:description" content="This is our inpainting page which allows you to remove or change the current input!..">
		
    <link rel="apple-touch-icon" sizes="180x180" href="assets/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="assets/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="assets/favicon-16x16.png">
	<link rel="manifest" href="assets/site.webmanifest">
	
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Swiper/4.5.0/scripts/swiper.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/fingerprintjs2@2.1.0/dist/fingerprint2.min.js"></script>
	
    <script src="https://www.gstatic.com/firebasejs/8.2.3/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.2.3/firebase-firestore.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.2.3/firebase-auth.js"></script>
	
	<script async src="https://fundingchoicesmessages.google.com/i/pub-2374246406180986?ers=1" nonce="usrhmUNMfjwqnwYPHoi0fQ"></script><script nonce="usrhmUNMfjwqnwYPHoi0fQ">(function() {function signalGooglefcPresent() {if (!window.frames['googlefcPresent']) {if (document.body) {const iframe = document.createElement('iframe'); iframe.style = 'width: 0; height: 0; border: none; z-index: -1000; left: -1000px; top: -1000px;'; iframe.style.display = 'none'; iframe.name = 'googlefcPresent'; document.body.appendChild(iframe);} else {setTimeout(signalGooglefcPresent, 0);}}}signalGooglefcPresent();})();</script>
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-PK4MEBN2XY"></script>
		<script type="module">
		import { auth, usersRef, paymentsRef, serversRef } from './scripts-17/firebase-config.js';

		const MAX_TASK_LIMIT = 2;

		const freeServerAddress = [
		  'https://12d7-217-131-85-121.ngrok-free.app'
		];
		
		const paidServerAddress = [
		];
		
		// Initialize the selected server address
		let serverAddresses = freeServerAddress;

		// The code you provided can be placed here
		let userId = 0;

		// Combo box element
		const versionSelector = document.getElementById('versionSelector');

		// Listen for changes in the combo box
		versionSelector.addEventListener('change', function () {
		  if (this.value === 'free') {
			serverAddresses = freeServerAddress;
		  } else if (this.value === 'paid') {
			serverAddresses = paidServerAddress;
		  }
		  
		  checkServerStatus();
		});

	function fetchWithCustomHeader(url, options, onProgress) {
	  const customHeaders = new Headers({
		'ngrok-skip-browser-warning': 'true',
	  });

	  options = options || {}; // Ensure options object exists
	  options.headers = options.headers || customHeaders;
  
	  if (typeof onProgress !== 'function') {
		// If onProgress is not a valid callback, use the standard fetch function
		return fetchWithRandom(url, options);
	  }
  
	  return new Promise((resolve, reject) => {
		const xhr = new XMLHttpRequest();
		xhr.open(options.method || 'GET', url);

		xhr.upload.onprogress = (event) => {
		  if (event.lengthComputable) {
			const progress = (event.loaded / event.total) * 100;
			// Call the progress callback with the current progress percentage
			onProgress(progress);
		  }
		};

		xhr.onload = () => {
		  if (xhr.status >= STATUS_OK && xhr.status < STATUS_NOTFOUND) {
			resolve(new Response(xhr.responseText, { status: xhr.status }));
		  } else {
			reject(new Error(`Request failed with status ${xhr.status}`));
		  }
		};

		xhr.onerror = () => {
		  reject(new Error('Request failed'));
		};

		// Set headers
		for (const [key, value] of options.headers) {
		  xhr.setRequestHeader(key, value);
		}

		// Send the request
		xhr.send(options.body);
	  });
	}

		let serverAddress = null;
		let intervalId = null;

		const startProcessBtn = document.getElementById('startProcessBtn');
		const previewMaskBtn = document.getElementById('previewMaskBtn');
		const serverOnlineBtn = document.getElementById('serverOnlineBtn');
		const downloadButton = document.getElementById('downloadButton');
		const sendResultsButton = document.getElementById('sendResultsButton');
		const statusDisplay = document.getElementById('statusDisplay');
		const serverDisplay = document.getElementById('serverDisplay');
		const progressBar = document.getElementById('progressBar');
		
		// Event listener for the sendResults button
		sendResultsButton.addEventListener('click', () => {
		  // Check if the user is authenticated
		  if (auth.currentUser) {
			  // Get the authenticated user's ID
			  userId = auth.currentUser.uid;
			  console.log('auth.currentUser.uid:', userId);
		  } else {
			  userId = 0;
			
			  // If the -1, show an error message or take appropriate action
              alert('You are not authenticated.');
			  return;
		  }
		  
			// Get references to the select elements and the sendResults button
			const restoreBodySelector = document.getElementById('restoreBodySelector').value;
			const tilingSelector = document.getElementById('tilingSelector').value;
			const samplerSelector = document.getElementById('samplerSelector').value;
			const modelSelector = document.getElementById('modelSelector').value;
			const resSelector = document.getElementById('resSelector').value;
			const modeSelector = document.getElementById('modeSelector').value;
			const clotheDetectionSelector = document.getElementById('clotheDetectionSelector').value;
			const breastSelector = document.getElementById('breastSelector').value;
			const genitaliaSelector = document.getElementById('genitaliaSelector').value;
			const textPrompt = document.getElementById('textPrompt').value;
			const textModelPrompt = document.getElementById('textModelPrompt').value;
			const pixelReference = document.getElementById('pixelReference').value;
			const inpaintReferenceMode = document.getElementById('inpaintReferenceMode').value;
			const clipSkip = document.getElementById('clipSkip').value;
			const configScale = document.getElementById('configScale').value;
			const denoisingStrenght = document.getElementById('denoisingStrenght').value;
			const dilateAmount = document.getElementById('dilateAmount').value;
		  
		  // Create an object with the data you want to send in the request body
		  const requestBody = {
			userId: userId,
			restoreBodySelector: restoreBodySelector,
			tilingSelector: tilingSelector,
			samplerSelector: samplerSelector,
			modelSelector: modelSelector,
			resSelector: resSelector,
			pixelReference: pixelReference,
			clipSkip: clipSkip,
			configScale: configScale,
			denoisingStrenght: denoisingStrenght,
			inpaintReferenceMode: inpaintReferenceMode,
		  };

		  // Send a POST request to the server's /set-results endpoint
		  fetchWithCustomHeader('https://25ca-217-131-85-121.ngrok-free.app/set-results', {
			method: 'POST',
			headers: {
			  'Content-Type': 'application/json',
			},
			body: JSON.stringify(requestBody),
		  })
			.then((response) => response.json())
			.then((data) => {
              alert(data.message);
			})
			.catch((error) => {
			  console.error('Error:', error);
              alert('An error occurred while sending settings.');
			});
		});
		
		const imageDisplayer = document.getElementById('imageDisplayer');
		imageDisplayer.style.display = 'none';

		function setClientStatus(message) {
		  statusDisplay.style.display = 'block';
		  statusDisplay.textContent =  'Status: ' + message;
		}

		function disableClientStatus(message) {
		  statusDisplay.style.display = 'none';
		}

		function setServerStatus(message) {
		  serverDisplay.style.display = 'block';
		  serverDisplay.textContent = 'Server status: ' + message;

		  // Check if the message is "You are not authenticated"
		  if (message === 'User is not authenticated.') {
			// Redirect to register.html after a 5-second countdown
			let countdown = 5;
			const countdownInterval = setInterval(() => {
			  if (countdown <= 0) {
				clearInterval(countdownInterval); // Stop the countdown
				window.location.href = 'register.html'; // Redirect to register.html
			  } else {
				serverDisplay.textContent = `Server status: ${message} - Redirecting in ${countdown} seconds.`;
				countdown--;
			  }
			}, 1000); // Update the countdown every second
		  }
		}

		function disableServerStatus(message) {
		  serverDisplay.style.display = 'none';
		}
		
		function setDownloadStatus(uniqueId) {
		  downloadButton.disabled = false;
		  downloadButton.dataset.uniqueId = uniqueId;
		}
		
		function disableDownloadStatus() {
		  downloadButton.disabled = true;
		  downloadButton.dataset.uniqueId = 0;
		}
		
		function downloadImage() {
		  const uniqueId = downloadButton.dataset.uniqueId;
		  if (uniqueId) {
			window.location.href = serverAddress + '/download-image/' + uniqueId;
		  }
		}

function setImageStatus(uniqueId) {
  // Reset variable.
  imageDisplayer.src = 0;
  imageDisplayer.style.display = 'none';

  // Create a request object with the required headers
  var headers = new Headers();
  headers.append('ngrok-skip-browser-warning', 'true');

  // Create the request
  var request = new Request(serverAddress + '/download-image/' + uniqueId, {
    method: 'GET',
    headers: headers,
  });

  // Fetch the image
  fetchWithCustomHeader(request)
    .then(function (response) {
      console.log('Response status:', response.status);
      console.log('Response headers:', response.headers);
      
      if (response.status === 200) {
        // Set the image source
        imageDisplayer.style.display = 'block';
        imageDisplayer.src = serverAddress + '/download-image/' + uniqueId;
      } else {
        imageDisplayer.src = 0;
        imageDisplayer.style.display = 'none';
        console.error('Failed to load image.');
      }
    })
    .catch(function (error) {
      imageDisplayer.src = 0;
      imageDisplayer.style.display = 'none';
      console.error('Error fetching image:', error);
    });
}
		
		function setMaskStatus(uniqueId) {
  // Reset variable.
  maskDisplayer.src = 0;
  maskDisplayer.style.display = 'none';

  // Create a request object with the required headers
  var headers = new Headers();
  headers.append('ngrok-skip-browser-warning', 'true');

  // Create the request
  var request = new Request(serverAddress + '/download-mask/' + uniqueId, {
    method: 'GET',
    headers: headers,
  });

  // Fetch the mask
  fetchWithCustomHeader(request)
    .then(function (response) {
      console.log('Response status:', response.status);
      console.log('Response headers:', response.headers);
      
      if (response.status === 200) {
        // Set the mask source
        maskDisplayer.style.display = 'block';
        maskDisplayer.src = serverAddress + '/download-mask/' + uniqueId;
      } else {
        maskDisplayer.src = 0;
        maskDisplayer.style.display = 'none';
        console.error('Failed to load image.');
      }
    })
    .catch(function (error) {
      maskDisplayer.src = 0;
      maskDisplayer.style.display = 'none';
      console.error('Error fetching image:', error);
    });
}
		
		function disableImageStatus() {
		  imageDisplayer.style.display = 'none';
		}
		
		function disableMaskStatus() {
		  maskDisplayer.style.display = 'none';
		}
		
		function updateProgressBar(progress) {
		  progressBar.style.display = 'block';
		  progressBar.style.width = `${progress}%`; // Set the width of the progress bar fill
		}

		updateProgressBar(0);

		function getLowestQueueIndex(queues) {
		  let lowestIndex = 0;
		  for (let i = 1; i < queues.length; i++) {
			if (queues[i] < queues[lowestIndex]) {
			  lowestIndex = i;
			}
		  }
		  return lowestIndex;
		}

		async function checkServerStatus() {
		  // Check if the user is authenticated
		  if (auth.currentUser) {
			  // Get the authenticated user's ID
			  userId = auth.currentUser.uid;
			  console.log('auth.currentUser.uid:', userId);
		  } 
	  
		  disableServerStatus();
		  setClientStatus('Checking server status...');
			let serverAvailable = false;

			// Create an array of promises to check the server status
			const promises = serverAddresses.map(server => {
			  return fetchWithCustomHeader(`${server}/get-online`)
				.then(response => {
				  if (response.status === STATUS_NOTFOUND) {
					// Handle server not found (404) error
					console.error(`Server ${server} is offline.`);
					return false; // Server is offline
				  } else if (response.status === 200) {
					// Server is online
					console.log(`Server ${server} is online.`);
					serverAvailable = true;
					return true; // Server is online
				  } else {
					console.error(`Error while fetching ${server}: Status ${response.status}`);
					return false; // Server is offline
				  }
				})
				.catch(error => {
				  console.error(`Error while fetching ${server}:`, error);
				  return false; // Server is offline
				});
			});

			// Check server status by awaiting all promises
			await Promise.all(promises);

			if (await !serverAvailable) {
			  setClientStatus('Server is offline.');
			  return;
			}

		  // Create a function to check server status and return a promise
		  const checkServerStatusPromise = async () => {
			const serverOffline = await Promise.race(promises.map(async serverPromise => {
			  try {
				return await serverPromise;
			  } catch (error) {
				return 'Server is offline';
			  }
			}));

			return serverOffline;
		  };

		  // Use the checkServerStatusPromise function to await server status
		  const serverOfflineResult = await checkServerStatusPromise();
		  if (serverOfflineResult === 'Server is offline') {
			setClientStatus('Server is offline.');
			return;
		  }

		  Promise.all(promises)
			.then(queues => {
			  const lowestQueueIndex = getLowestQueueIndex(queues);
			  if (queues[lowestQueueIndex] <= MAX_TASK_LIMIT) {
				setClientStatus(`Server ${lowestQueueIndex + 1} is online`);
			  } else {
				setClientStatus(`Trying to reconnect`);
				setServerStatus(`Servers are currently overloaded with tasks`);
				setTimeout(checkServerStatus, 4000);
			  }
			})
			.catch(error => {
			  console.error('Error while checking server statuses:', error);
			  setClientStatus('Error while checking server statuses');
			});
		}

		function getCurrentProcessStatus(uniqueId, lowestQueueIndex, serverAddress) {
		  if (!uniqueId) {
			startProcessBtn.disabled = false;
			setClientStatus('ID not available.');
			return;
		  }
		  
		  if (!serverAddress) {
			 startProcessBtn.disabled = false;
			 setClientStatus('Server not available.');
			 return;
		  }
				
		  setClientStatus(`Getting process status...`);
		  fetchWithCustomHeader(`${serverAddress}/get-process-state/${uniqueId}`)
			.then(response => response.json())
			.then(data => {
			  if (data.status === 'completed') {
			    startProcessBtn.disabled = false;
				clearInterval(intervalId);
				setClientStatus('Process completed');
				setServerStatus(`${data.server}`);
				setImageStatus(uniqueId);
				setDownloadStatus(uniqueId);
				updateProgressBar(0);
			  } else if (data.status === 'processing') {
				const processAmountResponse = data.processingAmount;
				updateProgressBar(processAmountResponse);
				  
				if (processAmountResponse > 0){ 
					const totalFramesResponse = data.totalFrames;
					const frameCountResponse = data.frameCount;
					const elapsedTimeResponse = data.elapsedTime;
					const remainingTimeResponse = data.remainingTime;
				
				  setServerStatus('%' + processAmountResponse 
				  + ' | Processed frames: ' + frameCountResponse + '/' + totalFramesResponse
				  + ' | Remaining time: ' + elapsedTimeResponse + '/' + remainingTimeResponse);
				}
				else {
					setServerStatus(`Starting body swap`);
				}
			
				disableImageStatus();
				disableDownloadStatus();
			  } else if (data.status === 'failed') {
			    startProcessBtn.disabled = false;
				clearInterval(intervalId);
				setClientStatus('Process failed');
				setServerStatus(`${data.server}`);
				updateProgressBar(0);
				disableImageStatus();
				disableDownloadStatus();
			  }
			})
			.catch(error => {
			  startProcessBtn.disabled = false;
			  console.error('Error while getting process status:', error);
			  setClientStatus('Error while getting process status');
			});
		}
		
		
		function getCurrentProcessStatusOfMask(uniqueId, lowestQueueIndex, serverAddress) {
		  if (!uniqueId) {
             clearInterval(intervalId);
			 setClientStatus('ID not available.');
			 return;
		  }
		  
		  if (!serverAddress) {
             clearInterval(intervalId);
			 setClientStatus('Server not available.');
			 return;
		  }
				
		  setClientStatus(`Getting process status...`);
		  fetchWithCustomHeader(`${serverAddress}/get-process-state-mask/${uniqueId}`)
			.then(response => response.json())
			.then(data => {
			  if (data.status === 'completed') {
				clearInterval(intervalId);
				setClientStatus('Process completed');
				setServerStatus(`${data.server}`);
				setMaskStatus(uniqueId);
				setDownloadStatus(uniqueId);
				updateProgressBar(0);
			  } else if (data.status === 'processing') {
				const processAmountResponse = data.processingAmount;
				updateProgressBar(processAmountResponse);
				  
				if (processAmountResponse > 0){ 
					const totalFramesResponse = data.totalFrames;
					const frameCountResponse = data.frameCount;
					const elapsedTimeResponse = data.elapsedTime;
					const remainingTimeResponse = data.remainingTime;
				
				  setServerStatus('%' + processAmountResponse 
				  + ' | Processed frames: ' + frameCountResponse + '/' + totalFramesResponse
				  + ' | Remaining time: ' + elapsedTimeResponse + '/' + remainingTimeResponse);
				}
				else {
					setServerStatus(`Starting body swap`);
				}
			
				disableMaskStatus();
				disableDownloadStatus();
			  } else if (data.status === 'failed') {
				clearInterval(intervalId);
				setClientStatus('Process failed');
				setServerStatus(`${data.server}`);
				updateProgressBar(0);
				disableMaskStatus();
				disableDownloadStatus();
			  }
			})
			.catch(error => {
              clearInterval(intervalId);
			  console.error('Error while getting process status:', error);
			  setClientStatus('Error while getting process status');
			});
		}
		
		const STATUS_OK = 200; 
		const STATUS_CREATED = 201; 
		const STATUS_BADREQUEST = 400; 
		const STATUS_UNAUTHORIZED = 401; 
		const STATUS_FORBIDDEN = 403; 
		const STATUS_NOTFOUND  = 404; 

// Function to convert webp to png
function convertWebpToPng(webpBlob) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();

    reader.onload = function () {
      const img = new Image();

      img.onload = function () {
        const canvas = document.createElement('canvas');
        canvas.width = img.width;
        canvas.height = img.height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0);

        // Convert the canvas content to a Blob with PNG format
        canvas.toBlob(
          (blob) => {
            resolve(blob);
          },
          'image/png',
          1 // PNG quality
        );
      };

      img.src = reader.result;
    };

    reader.readAsDataURL(webpBlob);
  });
}

function dataURItoBlob(dataURI) {
  // Convert base64/URLEncoded data component to raw binary data
  const byteString = atob(dataURI.split(',')[1]);

  // Separate out the mime component
  const mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0];

  // Write the bytes of the string to an ArrayBuffer
  const ab = new ArrayBuffer(byteString.length);
  const ia = new Uint8Array(ab);
  for (let i = 0; i < byteString.length; i++) {
    ia[i] = byteString.charCodeAt(i);
  }

  // Create a Blob from the ArrayBuffer and mime type
  return new Blob([ab], { type: mimeString });
}

startProcessBtn.addEventListener('click', async () => {
  const imageFile = document.getElementById('imageUploadInput').files[0];

  if (!imageFile) {
    setClientStatus('Please select an image');
    return;
  }

  // Check if the user is authenticated
  if (auth.currentUser) {
    // Get the authenticated user's ID
    userId = auth.currentUser.uid;
    console.log('auth.currentUser.uid:', userId);
  } else {
    userId = 0;

    // If the -1, show an error message or take appropriate action
    setServerStatus('User is not authenticated.');
    return;
  }

  // Check if the user is authenticated
  if (!userId) {
    // If the -1, show an error message or take appropriate action
    setServerStatus('User is not authenticated.');
    return;
  }

		// Get references to the select elements and the sendResults button
		const restoreBodySelector = document.getElementById('restoreBodySelector').value;
		const tilingSelector = document.getElementById('tilingSelector').value;
		const samplerSelector = document.getElementById('samplerSelector').value;
		const modelSelector = document.getElementById('modelSelector').value;
		const resSelector = document.getElementById('resSelector').value;
		const modeSelector = document.getElementById('modeSelector').value;
		const clotheDetectionSelector = document.getElementById('clotheDetectionSelector').value;
		const breastSelector = document.getElementById('breastSelector').value;
		const genitaliaSelector = document.getElementById('genitaliaSelector').value;
		const textPrompt = document.getElementById('textPrompt').value;
		const textModelPrompt = document.getElementById('textModelPrompt').value;
		const pixelReference = document.getElementById('pixelReference').value;
		const inpaintReferenceMode = document.getElementById('inpaintReferenceMode').value;
		const clipSkip = document.getElementById('clipSkip').value;
		const configScale = document.getElementById('configScale').value;
		const denoisingStrenght = document.getElementById('denoisingStrenght').value;
		const dilateAmount = document.getElementById('dilateAmount').value;
		
		  // Get the drawingCanvas element
const drawingCanvas = document.getElementById('drawingCanvas');

// Convert the canvas content to a data URL
const canvasDataURL = drawingCanvas.toDataURL('image/png'); // You can specify the desired image format

// Convert the data URL to a Blob
const canvasBlob = dataURItoBlob(canvasDataURL);

// Create a File object from the Blob (optional, depending on your server's requirements)
const imageMask = new File([canvasBlob], 'drawing.png', { type: 'image/png' });

  disableClientStatus();
  disableServerStatus();
  disableImageStatus();
  disableDownloadStatus();
  updateProgressBar(0);
  setClientStatus(`Connecting to server...`);

  // Disable the button when clicked
  startProcessBtn.disabled = true;
			
	// Define a variable to store the start time of the upload
	let startTime;
	let serverAvailable = false;

	// Create an array of promises to check the server status
	const promises = serverAddresses.map(server => {
	  return fetchWithCustomHeader(`${server}/get-online`)
		.then(response => {
		  if (response.status === STATUS_NOTFOUND) {
			// Handle server not found (404) error
			console.error(`Server ${server} is offline.`);
			return false; // Server is offline
		  } else if (response.status === 200) {
			// Server is online
			console.log(`Server ${server} is online.`);
			serverAvailable = true;
			return true; // Server is online
		  } else {
			console.error(`Error while fetching ${server}: Status ${response.status}`);
			return false; // Server is offline
		  }
		})
		.catch(error => {
		  console.error(`Error while fetching ${server}:`, error);
		  return false; // Server is offline
		});
	});

	// Check server status by awaiting all promises
	await Promise.all(promises);

	if (await !serverAvailable) {
	  setClientStatus('Server is offline.');
	  return;
	}

  // Create a function to check server status and return a promise
  const checkServerStatusPromise = async () => {
    const serverOffline = await Promise.race(promises.map(async serverPromise => {
      try {
        return await serverPromise;
      } catch (error) {
        return 'Server is offline';
      }
    }));

    return serverOffline;
  };

  // Use the checkServerStatusPromise function to await server status
  const serverOfflineResult = await checkServerStatusPromise();
  if (serverOfflineResult === 'Server is offline') {
    setClientStatus('Server is offline.');
    return;
  }

  Promise.all(promises)
    .then((queues) => {
      const lowestQueueIndex = getLowestQueueIndex(queues);
      if (queues[lowestQueueIndex] <= MAX_TASK_LIMIT) {
        serverAddress = serverAddresses[lowestQueueIndex];
        setClientStatus(`Be patient while fetching process on server ${lowestQueueIndex + 1}`);

        // Convert webp to png if needed
        if (imageFile.type === 'image/webp') {
          convertWebpToPng(imageFile)
            .then((pngBlob) => {
              const formData = new FormData();
              formData.append('image', new File([pngBlob], 'image.png', { type: 'image/png' }));
		      formData.append('imageMask', imageMask);
              formData.append('userId', userId);
              formData.append('restoreBodySelector', restoreBodySelector);
              formData.append('tilingSelector', tilingSelector);
              formData.append('samplerSelector', samplerSelector);
              formData.append('modelSelector', modelSelector);
              formData.append('resSelector', resSelector);
              formData.append('modeSelector', modeSelector);
              formData.append('clotheDetectionSelector', clotheDetectionSelector);
              formData.append('breastSelector', breastSelector);
              formData.append('genitaliaSelector', genitaliaSelector);
              formData.append('textPrompt', textPrompt);
			  formData.append('textModelPrompt', textModelPrompt);
			  formData.append('pixelReference', pixelReference);
			  formData.append('inpaintReferenceMode', inpaintReferenceMode);
			  formData.append('clipSkip', clipSkip);
			  formData.append('configScale', configScale);
			  formData.append('denoisingStrenght', denoisingStrenght);
              formData.append('dilateAmount', dilateAmount);
		
				fetchWithCustomHeader(
				  `${serverAddress}/start-process`,
				  {
					method: 'POST',
					body: formData,
				  },
				  (progress) => {
					if (!startTime && progress > 0) {
					  // Record the start time when the first progress event is received
					  startTime = Date.now();
					}

					if (startTime) {
					  // Calculate upload speed in kilobytes per second
					  const currentTime = Date.now();
					  const elapsedTimeInSeconds = (currentTime - startTime) / 1000;
					  const uploadSpeedKBps = progress / elapsedTimeInSeconds / 1024;

					  // Round the upload speed to two decimal places for display
					  const formattedUploadSpeed = uploadSpeedKBps >= 1024
						? `${(uploadSpeedKBps / 1024).toFixed(2)} MB/s`
						: `${uploadSpeedKBps.toFixed(2)} KB/s`;

					  // Log the upload speed and progress percentage with dynamic formatting
					  console.log(`Upload progress: ${progress.toFixed(2)}%`);
					  console.log(`Upload speed: ${formattedUploadSpeed}`);

					  // Pass the upload speed to the setServerStatus function
					  setServerStatus(`Upload speed is ${formattedUploadSpeed}`);
					}

					// Calculate and update progress in real-time
					const progressBar = document.getElementById('progressBar');
					progressBar.style.width = `${progress}%`;
				  }
				)
				.then(response => {
				  if (response.status === STATUS_OK) {
					return response.json();
				  } else if (response.status === STATUS_NOTFOUND) {
					// Handle server not found (404) error
					setClientStatus('Server is offline.');
				  } else {
					return response.json().then(data => {
					  throw new Error(data.server);
					});
				  }
				})
                .then((data) => {
                  const uniqueId = data.uniqueId;
                  intervalId = setInterval(() => {
                    getCurrentProcessStatus(uniqueId, lowestQueueIndex, serverAddress);
                  }, 4000);
                })
                .catch((error) => {
				  startProcessBtn.disabled = false;
                  console.error('Error while starting process:', error);
                  clearInterval(intervalId);
                  setClientStatus('Error while starting process');
                  setServerStatus(error.message);
                });
            })
            .catch((conversionError) => {
			  startProcessBtn.disabled = false;
              clearInterval(intervalId);
              console.error('Error while converting webp to png:', conversionError);
              setClientStatus('Error while converting webp to png');
            });
        } else {
          // Image is not in webp format, proceed with the original image
          const formData = new FormData();
          formData.append('image', imageFile);
		  formData.append('imageMask', imageMask);
          formData.append('userId', userId);
          formData.append('restoreBodySelector', restoreBodySelector);
          formData.append('tilingSelector', tilingSelector);
          formData.append('samplerSelector', samplerSelector);
          formData.append('modelSelector', modelSelector);
          formData.append('resSelector', resSelector);
          formData.append('modeSelector', modeSelector);
          formData.append('clotheDetectionSelector', clotheDetectionSelector);
          formData.append('breastSelector', breastSelector);
          formData.append('genitaliaSelector', genitaliaSelector);
          formData.append('textPrompt', textPrompt);
			  formData.append('pixelReference', pixelReference);
			  formData.append('inpaintReferenceMode', inpaintReferenceMode);
			  formData.append('clipSkip', clipSkip);
			  formData.append('configScale', configScale);
			  formData.append('denoisingStrenght', denoisingStrenght);
          formData.append('textModelPrompt', textModelPrompt);
          formData.append('dilateAmount', dilateAmount);

				fetchWithCustomHeader(
				  `${serverAddress}/start-process`,
				  {
					method: 'POST',
					body: formData,
				  },
				  (progress) => {
					if (!startTime && progress > 0) {
					  // Record the start time when the first progress event is received
					  startTime = Date.now();
					}

					if (startTime) {
					  // Calculate upload speed in kilobytes per second
					  const currentTime = Date.now();
					  const elapsedTimeInSeconds = (currentTime - startTime) / 1000;
					  const uploadSpeedKBps = progress / elapsedTimeInSeconds / 1024;

					  // Round the upload speed to two decimal places for display
					  const formattedUploadSpeed = uploadSpeedKBps >= 1024
						? `${(uploadSpeedKBps / 1024).toFixed(2)} MB/s`
						: `${uploadSpeedKBps.toFixed(2)} KB/s`;

					  // Log the upload speed and progress percentage with dynamic formatting
					  console.log(`Upload progress: ${progress.toFixed(2)}%`);
					  console.log(`Upload speed: ${formattedUploadSpeed}`);

					  // Pass the upload speed to the setServerStatus function
					  setServerStatus(`Upload speed is ${formattedUploadSpeed}`);
					}

					// Calculate and update progress in real-time
					const progressBar = document.getElementById('progressBar');
					progressBar.style.width = `${progress}%`;
				  }
				)
			.then(response => {
			  if (response.status === STATUS_OK) {
				return response.json();
			  } else if (response.status === STATUS_NOTFOUND) {
				// Handle server not found (404) error
				setClientStatus('Server is offline.');
			  } else {
				return response.json().then(data => {
				  throw new Error(data.server);
				});
			  }
			})
            .then((data) => {
              const uniqueId = data.uniqueId;
              intervalId = setInterval(() => {
                getCurrentProcessStatus(uniqueId, lowestQueueIndex, serverAddress);
              }, 4000);
            })
            .catch((error) => {
			  startProcessBtn.disabled = false;
              console.error('Error while starting process:', error);
              clearInterval(intervalId);
              setClientStatus('Error while starting process');
              setServerStatus(error.message);
            });
        }
      } else {
		startProcessBtn.disabled = false;
        setClientStatus(`Trying to reconnect.`);
        setServerStatus(`Servers are currently overloaded with tasks`);
        setTimeout(checkServerStatus, 4000);
        serverAddress = null;
      }
    })
    .catch((error) => {
	  startProcessBtn.disabled = false;
      console.error('Error while checking server statuses:', error);
      clearInterval(intervalId);
      setClientStatus(`Server is not accessible.`);
      serverAddress = null;
    });
});

previewMaskBtn.addEventListener('click', async () => {
  const imageFile = document.getElementById('imageUploadInput').files[0];
  if (!imageFile) {
    setClientStatus('Please select an image.');
    return;
  }

  // Check if the user is authenticated
  if (auth.currentUser) {
    // Get the authenticated user's ID
    userId = auth.currentUser.uid;
    console.log('auth.currentUser.uid:', userId);
  } else {
    userId = 0;

    // If the -1, show an error message or take appropriate action
    setServerStatus('User is not authenticated.');
    return;
  }

  // Check if the user is authenticated
  if (!userId) {
    // If the -1, show an error message or take appropriate action
    setServerStatus('User is not authenticated.');
    return;
  }

		// Get references to the select elements and the sendResults button
		const restoreBodySelector = document.getElementById('restoreBodySelector').value;
		const tilingSelector = document.getElementById('tilingSelector').value;
		const samplerSelector = document.getElementById('samplerSelector').value;
		const modelSelector = document.getElementById('modelSelector').value;
		const resSelector = document.getElementById('resSelector').value;
		const modeSelector = document.getElementById('modeSelector').value;
		const clotheDetectionSelector = document.getElementById('clotheDetectionSelector').value;
		const breastSelector = document.getElementById('breastSelector').value;
		const genitaliaSelector = document.getElementById('genitaliaSelector').value;
		const textPrompt = document.getElementById('textPrompt').value;
		const textModelPrompt = document.getElementById('textModelPrompt').value;
		const pixelReference = document.getElementById('pixelReference').value;
		const inpaintReferenceMode = document.getElementById('inpaintReferenceMode').value;
		const clipSkip = document.getElementById('clipSkip').value;
		const configScale = document.getElementById('configScale').value;
		const denoisingStrenght = document.getElementById('denoisingStrenght').value;
		const dilateAmount = document.getElementById('dilateAmount').value;

  disableClientStatus();
  disableServerStatus();
  disableImageStatus();
  disableDownloadStatus();
  updateProgressBar(0);
  setClientStatus(`Connecting to server...`);

	// Define a variable to store the start time of the upload
	let startTime;
	let serverAvailable = false;

	// Create an array of promises to check the server status
	const promises = serverAddresses.map(server => {
	  return fetchWithCustomHeader(`${server}/get-online`)
		.then(response => {
		  if (response.status === STATUS_NOTFOUND) {
			// Handle server not found (404) error
			console.error(`Server ${server} is offline.`);
			return false; // Server is offline
		  } else if (response.status === 200) {
			// Server is online
			console.log(`Server ${server} is online.`);
			serverAvailable = true;
			return true; // Server is online
		  } else {
			console.error(`Error while fetching ${server}: Status ${response.status}`);
			return false; // Server is offline
		  }
		})
		.catch(error => {
		  console.error(`Error while fetching ${server}:`, error);
		  return false; // Server is offline
		});
	});

	// Check server status by awaiting all promises
	await Promise.all(promises);

	if (await !serverAvailable) {
	  setClientStatus('Server is offline.');
	  return;
	}

  // Create a function to check server status and return a promise
  const checkServerStatusPromise = async () => {
    const serverOffline = await Promise.race(promises.map(async serverPromise => {
      try {
        return await serverPromise;
      } catch (error) {
        return 'Server is offline';
      }
    }));

    return serverOffline;
  };

  // Use the checkServerStatusPromise function to await server status
  const serverOfflineResult = await checkServerStatusPromise();
  if (serverOfflineResult === 'Server is offline') {
    setClientStatus('Server is offline.');
    return;
  }

  Promise.all(promises)
    .then((queues) => {
      const lowestQueueIndex = getLowestQueueIndex(queues);
      if (queues[lowestQueueIndex] <= MAX_TASK_LIMIT) {
        serverAddress = serverAddresses[lowestQueueIndex];
        setClientStatus(`Be patient while fetching process on server ${lowestQueueIndex + 1}`);

        // Convert webp to png if needed
        if (imageFile.type === 'image/webp') {
          convertWebpToPng(imageFile)
            .then((pngBlob) => {
              const formData = new FormData();
              formData.append('image', new File([pngBlob], 'image.png', { type: 'image/png' }));
              formData.append('userId', userId);
              formData.append('restoreBodySelector', restoreBodySelector);
              formData.append('tilingSelector', tilingSelector);
              formData.append('samplerSelector', samplerSelector);
              formData.append('modelSelector', modelSelector);
              formData.append('resSelector', resSelector);
              formData.append('modeSelector', modeSelector);
              formData.append('clotheDetectionSelector', clotheDetectionSelector);
              formData.append('breastSelector', breastSelector);
              formData.append('genitaliaSelector', genitaliaSelector);
              formData.append('textPrompt', textPrompt);
			  formData.append('pixelReference', pixelReference);
			  formData.append('inpaintReferenceMode', inpaintReferenceMode);
			  formData.append('clipSkip', clipSkip);
			  formData.append('configScale', configScale);
			  formData.append('denoisingStrenght', denoisingStrenght);
			  formData.append('textModelPrompt', textModelPrompt);
              formData.append('dilateAmount', dilateAmount);
			  formData.append('justMask', true);

				fetchWithCustomHeader(
				  `${serverAddress}/start-process`,
				  {
					method: 'POST',
					body: formData,
				  },
				  (progress) => {
					if (!startTime && progress > 0) {
					  // Record the start time when the first progress event is received
					  startTime = Date.now();
					}

					if (startTime) {
					  // Calculate upload speed in kilobytes per second
					  const currentTime = Date.now();
					  const elapsedTimeInSeconds = (currentTime - startTime) / 1000;
					  const uploadSpeedKBps = progress / elapsedTimeInSeconds / 1024;

					  // Round the upload speed to two decimal places for display
					  const formattedUploadSpeed = uploadSpeedKBps >= 1024
						? `${(uploadSpeedKBps / 1024).toFixed(2)} MB/s`
						: `${uploadSpeedKBps.toFixed(2)} KB/s`;

					  // Log the upload speed and progress percentage with dynamic formatting
					  console.log(`Upload progress: ${progress.toFixed(2)}%`);
					  console.log(`Upload speed: ${formattedUploadSpeed}`);

					  // Pass the upload speed to the setServerStatus function
					  setServerStatus(`Upload speed is ${formattedUploadSpeed}`);
					}

					// Calculate and update progress in real-time
					const progressBar = document.getElementById('progressBar');
					progressBar.style.width = `${progress}%`;
				  }
				)
				.then(response => {
				  if (response.status === STATUS_OK) {
					return response.json();
				  } else if (response.status === STATUS_NOTFOUND) {
					// Handle server not found (404) error
					setClientStatus('Server is offline.');
				  } else {
					return response.json().then(data => {
					  throw new Error(data.server);
					});
				  }
				})
                .then((data) => {
                  const uniqueId = data.uniqueId;
                  intervalId = setInterval(() => {
                    getCurrentProcessStatusOfMask(uniqueId, lowestQueueIndex, serverAddress);
                  }, 4000);
                })
                .catch((error) => {
                  console.error('Error while starting process:', error);
                  clearInterval(intervalId);
                  setClientStatus('Error while starting process');
                  setServerStatus(error.message);
                });
            })
            .catch((conversionError) => {
              clearInterval(intervalId);
              console.error('Error while converting webp to png:', conversionError);
              setClientStatus('Error while converting webp to png');
            });
        } else {
          // Image is not in webp format, proceed with the original image
          const formData = new FormData();
          formData.append('image', imageFile);
          formData.append('userId', userId);
          formData.append('restoreBodySelector', restoreBodySelector);
          formData.append('tilingSelector', tilingSelector);
          formData.append('samplerSelector', samplerSelector);
          formData.append('modelSelector', modelSelector);
          formData.append('resSelector', resSelector);
          formData.append('modeSelector', modeSelector);
          formData.append('clotheDetectionSelector', clotheDetectionSelector);
          formData.append('breastSelector', breastSelector);
          formData.append('genitaliaSelector', genitaliaSelector);
          formData.append('textPrompt', textPrompt);
          formData.append('textModelPrompt', textModelPrompt);
			  formData.append('pixelReference', pixelReference);
			  formData.append('inpaintReferenceMode', inpaintReferenceMode);
			  formData.append('clipSkip', clipSkip);
			  formData.append('configScale', configScale);
			  formData.append('denoisingStrenght', denoisingStrenght);
          formData.append('dilateAmount', dilateAmount);
          formData.append('justMask', true);

			fetchWithCustomHeader(
			  `${serverAddress}/start-process`,
			  {
				method: 'POST',
				body: formData,
			  },
			  (progress) => {
				if (!startTime && progress > 0) {
				  // Record the start time when the first progress event is received
				  startTime = Date.now();
				}

				if (startTime) {
				  // Calculate upload speed in kilobytes per second
				  const currentTime = Date.now();
				  const elapsedTimeInSeconds = (currentTime - startTime) / 1000;
				  const uploadSpeedKBps = progress / elapsedTimeInSeconds / 1024;

				  // Round the upload speed to two decimal places for display
				  const formattedUploadSpeed = uploadSpeedKBps >= 1024
					? `${(uploadSpeedKBps / 1024).toFixed(2)} MB/s`
					: `${uploadSpeedKBps.toFixed(2)} KB/s`;

				  // Log the upload speed and progress percentage with dynamic formatting
				  console.log(`Upload progress: ${progress.toFixed(2)}%`);
				  console.log(`Upload speed: ${formattedUploadSpeed}`);

				  // Pass the upload speed to the setServerStatus function
				  setServerStatus(`Upload speed is ${formattedUploadSpeed}`);
				}

				// Calculate and update progress in real-time
				const progressBar = document.getElementById('progressBar');
				progressBar.style.width = `${progress}%`;
			  }
			)
			.then(response => {
			  if (response.status === STATUS_OK) {
				return response.json();
			  } else if (response.status === STATUS_NOTFOUND) {
				// Handle server not found (404) error
				setClientStatus('Server is offline.');
			  } else {
				return response.json().then(data => {
				  throw new Error(data.server);
				});
			  }
			})
            .then((data) => {
              const uniqueId = data.uniqueId;
              intervalId = setInterval(() => {
                getCurrentProcessStatusOfMask(uniqueId, lowestQueueIndex, serverAddress);
              }, 4000);
            })
            .catch((error) => {
              console.error('Error while starting process:', error);
              clearInterval(intervalId);
              setClientStatus('Error while starting process');
              setServerStatus(error.message);
            });
        }
      } else {
        setClientStatus(`Trying to reconnect.`);
        setServerStatus(`Servers are currently overloaded with tasks`);
        setTimeout(checkServerStatus, 4000);
        serverAddress = null;
      }
    })
    .catch((error) => {
      console.error('Error while checking server statuses:', error);
      clearInterval(intervalId);
      setClientStatus(`Server is not accessible.`);
      serverAddress = null;
    });
});

		serverOnlineBtn.addEventListener('click', () => {
		  checkServerStatus();
		});
		
		let imageUploadCompleted = false;

		function handleImageUpload() {
		  imageUploadCompleted = true;
		  updateStartProcessButton();
		}

		function updateStartProcessButton() {
		  startProcessBtn.disabled = !imageUploadCompleted;
		  previewMaskBtn.disabled = !imageUploadCompleted;
		}

		document.getElementById('imageUploadInput').addEventListener('change', handleImageUpload);
		downloadButton.addEventListener('click', downloadImage);</script>
		
    <link rel="stylesheet" href="styles-17/main.css">
    <link rel="stylesheet" href="styles-17/background.css">
    <link rel="stylesheet" href="styles-17/products.css">
		<style> 
		/* Style the rectangle */
		.rectangle {
		  width: 200px; /* Adjust width as needed */
		  height: 50px; /* Initial height of the rectangle */
		  background-color: var(--background-color); /* Replace with your preferred background color */
		  box-shadow: 0px var(--card-main-box-shadow-1-y) var(--card-main-box-shadow-1-blur) var(--card-main-box-shadow-1),
					  0px var(--card-main-box-shadow-1-y) var(--card-main-box-shadow-1-blur) var(--card-main-box-shadow-1),
					  0 0 0 1px var(--card-main-border-color); /* Replace with your preferred box-shadow and border styles */
		  padding: 16px; /* Adjust padding as needed */
		  border-radius: 15px; /* Adjust border radius as needed */
		  cursor: pointer; /* Add a pointer cursor to indicate interactivity */
		  position: relative;
		  transition: box-shadow 0.25s; /* Add a smooth transition for box-shadow changes */
		  flex: 1;
		  margin: 0 auto;
		}
/* Style the container for mode selector and text input */
.mode-and-text-container {
  display: flex;
  align-items: center;
  margin-top: 10px; /* Add spacing from the elements above */
}

/* Adjust the margin between the mode selector and text input */
.mode-selector-container {
  margin-right: 10px; /* Add spacing between clotheDetectionSelector and textPrompt */
}

/* Style the text input container */
.text-container {
  flex-grow: 1; /* Allow the text input to grow and fill available space */
  display: flex;
  align-items: center;
}

/* Style the text input */
#textPrompt {
  width: 100%; /* Make the text input expand to fill its container */
}
#textModelPrompt {
  width: 100%; /* Make the text input expand to fill its container */
}
		/* Style the triangle */
		.triangle {
		  width: 0;
		  height: 0;
		  border-left: 20px solid transparent; /* Adjust the width of the triangle */
		  border-right: 20px solid transparent; /* Adjust the width of the triangle */
		  border-top: 20px solid var(--text-color); /* Adjust the color and size of the triangle */
		  position: absolute;
		  top: 50%; /* Initially centered vertically */
		  left: 50%; /* Initially centered horizontally */
		  transform: translate(-50%, -50%); /* Center the triangle both vertically and horizontally */
		  transition: transform 0.5s; /* Add transition for smooth scaling */
		}

		/* Add a class to reverse the triangle shape */
		.triangle-reversed {
		  transform: translate(-50%, -50%) scaleY(-1); /* Flip the triangle vertically without changing its position */]
		}

		/* Style the expanded content */
		.expanded-content {
		  max-height: 0;
		  overflow: hidden;
		  transition: max-height 0.3s ease-in-out; /* Add a smooth transition effect */
		}
		#textPrompt {
	  margin: auto;
	}
		.center-expandable-box {
		  display: flex;
		  justify-content: center;
		  align-items: center;
		  text-align: center;
		}
		</style>
	    <style>
        .canvas-container {
            position: relative;
        }

        img {
            max-width: 100%;
            height: auto;
            display: block;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        /* Style for the slider container */
        .slider-container {
            position: absolute;
            top: 10px; /* Adjust the top position */
            right: 20px; /* Adjust the right position, smaller value to move it left */
            width: 150px; /* Adjust the width as needed */
        }

        /* Style for the slider */
        #sizeSlider {
            width: 100%; /* Make the slider fill the container */
        }

        /* Style for the color picker container */
        .color-picker-container {
            position: absolute;
            top: 50px; /* Adjust the top position to be below the slider */
            right: -32px; /* Position it to the right of the image */
            width: 150px; /* Adjust the width as needed */
        }

        /* Style for the cursor */
        canvas.drawing {
            cursor: crosshair;
        }

        .custom-slider {
            /* Define your custom styles here */
            width: 150px; /* Adjust the width as needed */
            height: 10px; /* Adjust the height as needed */
            background-color: #ccc;
            border: none;
            outline: none;
            border-radius: 5px;
            -webkit-appearance: none; /* Remove default styles in WebKit browsers */
        }

        .custom-slider::-webkit-slider-thumb {
            /* Style the slider thumb */
            width: 20px; /* Adjust the thumb width */
            height: 20px; /* Make the thumb square by setting the same height and width */
            background-color: white; /* Set the thumb color to white */
            border: 2px solid #0078d4; /* Add a 2px border with the desired color */
            border-radius: 5px; /* Add a small border-radius for a smoother look */
            -webkit-appearance: none; /* Remove default styles in WebKit browsers */
        }
    </style>
	</head>
	<body translate="no">
		<nav class="navbar">
			<div class="logo">BodySwap</div>
			<label class="day-night">
				<input type="checkbox" checked>
				<div></div>
			</label>
			<div class="menu-toggle">
				<div class="hamburger"></div>
				<div class="hamburger"></div>
				<div class="hamburger"></div>
			</div>
			<ul class="nav-links" id="nav-links">
				<li><a id="emailVerificationMessage" style="color: red; display: none; text-align: center;">Sent Verification E-Mail.</a></li>
				<li><a id="loggedInMessage"></a></li>
				<li><a id="logoutButton" style="display: none; cursor: pointer;">Log Out</a></li>
				<li><a id="sendVerificationButton" style="display: block; cursor: pointer;">Send Verification</a></li>
				<li><a href="https://bodyswap.me/index.html">Home</a></li>
				<li><a href="deepfake.html">DeepFake</a></li>
				<li><a href="deepnude.html">DeepNude</a></li>
				<li><a href="pricing.html">Pricing</a></li>
				<li><a href="policies.html">Policies</a></li>
				<li><a href="https://discord.gg/qKdm9r98zR" target="_blank">Discord</a></li>
				<li><a href="https://www.trustpilot.com/review/bodyswap.me" target="_blank">Trustpilot</a></li>
				<li><a href="login.html" id="loginLink">Sign in</a></li>
				<li><a href="register.html" id="registerLink">Sign up</a></li>
				<li><a href="profile.html">Free Credits</a></li>
			</ul>
		</nav>
		<div class="container hero">
			<div class="background">
				<canvas id="hero-canvas" width="1920" height="1080"></canvas>
			</div>
		</div>
	  <div style="text-align: center; padding: 65px;">
		<label for="versionSelector">Choose a version:</label>
		<select id="versionSelector">
		  <option value="free">Free</option>
		</select>
		<div style="padding: 10px;"></div>
		<div class="upload-container">
		  <div class="upload-box">
			<h2>Image Upload</h2>
			<input type="file" class="upload-input" id="imageUploadInput" accept="image/*" onchange="previewImage(event, 'imagePreview')">
			<img id="imagePreview" class="preview" src="" alt="Image Preview">
		  </div>
		</div>
		<div style="padding: 15px;"></div>
		<button id="serverOnlineBtn">Check Server Status</button>
		<button id="startProcessBtn" disabled>Start Process</button>
		<button id="downloadButton" disabled>Download Result</button>
		<pre id="statusDisplay"></pre>
		<pre id="serverDisplay"></pre>
		<div style="padding: 5px;"></div>
		<image id="imageDisplayer" controls style="display: block; margin: 0 auto; width: 25%; height: auto; outline: none; border: none; object-fit: cover;"></image>
		<div class="progress-bar"> <div class="progress-bar-fill" id="progressBar"></div></div>
	  </div>
	  <div style="margin-top: -65px;">
		<div style="text-align: center; ">
		  <h2>Advanced Settings</h2>
		  <div style="margin-top: -15px;"></div>
		</div>
		<div class="center-expandable-box">
		  <div id="expandableBox">
			<div class="rectangle" id="triangleContainer">
			  <div class="triangle" id="triangle"></div>
			</div>
			<div class="expanded-content">
				<div class="mode-and-text-container">
				  <div class="mode-selector-container">
				  	<h2 id="nudifierDescription" style="display: block; text-align: center; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
					  These settings will change the outcome by your desires!
					</h2>
					<div style="margin-top: -15px;"></div>
					<label for="modeSelector">Style mode:</label>
					<select id="modeSelector">
					  <option value="realistic">Realistic</option>
					  <option value="anime">Anime</option>
					</select>
					<label for="genitaliaSelector">Genitalia mode:</label>
					<select id="genitaliaSelector">
					  <option value="Vagina">Vagina</option>
					  <option value="Penis">Penis</option>
					</select>
					<label for="resSelector">Resolution fixer:</label>
					<select id="resSelector">
					  <option value="automatic">Automatically</option>
					  <option value="default">Default</option>
					</select>
					<label for="breastSelector">Breast mode:</label>
					<select id="breastSelector">
					  <option value="automatic">Automatically</option>
					  <option value="flatChest">Flat chest</option>
					  <option value="smallBreast">Small breast</option>
					  <option value="mediumBreast">Medium breast</option>
					  <option value="bigBreast">Big breast</option>
					</select>
					<label for="clotheDetectionSelector">Clothe detection mode:</label>
					<select id="clotheDetectionSelector">
					  <option value="automatic">Automatically</option>
					  <option value="prompt">Prompt based</option>
					  <option value="manual">Manually mask</option>
					</select>
				    <div class="text-container">
					  <input type="text" id="textPrompt" placeholder="Enter your mask prompt... (e.g., bra, underwear)">
				    </div>
				    <div class="text-container">
					  <input type="text" id="textModelPrompt" placeholder="Enter your model prompt... (Leave blank if you want nude | e.g., bikini)">
				    </div>
				  <div style="display: flex;
						flex-direction: column;
						align-items: center;
						margin: 0;"> 
					<div class="canvas-container">
						<img id="imageMask" src="" alt="Your Image">
						<canvas id="drawingCanvas" class="drawing"></canvas>
						<div class="slider-container">
							<input type="range" id="sizeSlider" min="1" max="50" value="5" step="4" class="custom-slider">
						</div>
						<div class="color-picker-container">
							<input type="color" id="colorPicker" value="#000000">
						</div>
					</div>
				  </div>
				  </div>
				</div>
				<h2 id="nudifierDescription" style="display: block; text-align: center; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
					These settings will change the used algorithm!
				</h2>
				<div style="margin-top: -15px;"></div>
				<label for="modelSelector">Model:</label>
				<select id="modelSelector">
					<option value="Default">Default</option>
					<option value="V4">Old</option>
				</select>
				<label for="samplerSelector">Sampler:</label>
				<select id="samplerSelector">
					<option value="2M">Fast sampler</option>
					<option value="SDE">Slow sampler</option>
				</select>
				<label for="restoreBodySelector">Restoration:</label>
				<select id="restoreBodySelector">
					<option value="False">Disabled</option>
					<option value="True">Enabled</option>
				</select>
				<label for="tilingSelector">Tiling:</label>
				<select id="tilingSelector">
					<option value="False">Disabled</option>
					<option value="True">Enabled</option>
				</select>
				<label for="inpaintReferenceMode">Reference:</label>
				<select id="inpaintReferenceMode">
					<option value="False">Whole picture</option>
					<option value="True">Masked area only</option>
				</select>
				<div style="margin-top: -0px;"></div>
				<label for="pixelReference">Pixel reference:</label>
				<input type="range" id="pixelReference" name="pixelReference" min="0" max="256" value="32">
				<label for="clipSkip">Mask Blur:</label>
				<input type="range" id="clipSkip" name="clipSkip" min="0" max="12" value="4">
				<label for="configScale">Prompt importance:</label>
				<input type="range" id="configScale" name="configScale" min="1" max="12" value="7">
				<label for="denoisingStrenght">Denoising strenght:</label>
				<input type="range" id="denoisingStrenght" name="denoisingStrenght" min="0" max="100" value="100">
				<div style="margin-top: -0px;"></div>
				<h2 id="modelsDescription" style="display: block; text-align: center; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">Click on this button after testing settings, this will help us to improve the results!</h2>
				<div style="margin-top: -10px;"></div>
				<button id="sendResultsButton">Save settings</button>
				<div style="padding: 5px;"></div>
			</div>
			<label for="dilateAmount">Dilate Mask:</label>
			<input type="range" id="dilateAmount" name="dilateAmount" min="0" max="35" value="10">
			<button id="previewMaskBtn" disabled>Preview mask</button>
			<image id="maskDisplayer" controls style="display: block; margin: 0 auto; width: 25%; height: auto; outline: none; border: none; object-fit: cover;"></image>
		  </div>
		</div>	
		<div style="text-align: center; ">
			<h3 id="clothesDescription" style="display: none; text-align: center; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
			  Please list the clothing items worn by the individual, and remember to include a comma between each item (e.g., bra, underwear). You can specify by saying, 'clothing worn by the woman on the left.'
			</h3>
	    </div>
	  </div>
	  <div class="instructions-container">
		<div class="card-main">
		  <span class="icon">
			<svg viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round" xmlns="http://www.w3.org/2000/svg"><path d="M4.5 9.5V5.5C4.5 4.94772 4.94772 4.5 5.5 4.5H9.5C10.0523 4.5 10.5 4.94772 10.5 5.5V9.5C10.5 10.0523 10.0523 10.5 9.5 10.5H5.5C4.94772 10.5 4.5 10.0523 4.5 9.5Z"></path><path d="M13.5 18.5V14.5C13.5 13.9477 13.9477 13.5 14.5 13.5H18.5C19.0523 13.5 19.5 13.9477 19.5 14.5V18.5C19.5 19.0523 19.0523 19.5 18.5 19.5H14.5C13.9477 19.5 13.5 19.0523 13.5 18.5Z"></path><path d="M4.5 19.5L7.5 13.5L10.5 19.5H4.5Z"></path><path d="M16.5 4.5C18.1569 4.5 19.5 5.84315 19.5 7.5C19.5 9.15685 18.1569 10.5 16.5 10.5C14.8431 10.5 13.5 9.15685 13.5 7.5C13.5 5.84315 14.8431 4.5 16.5 4.5Z"></path></svg>
		  </span>
		  <h4>Start Process</h4>
		  <p>Click "Start Process" once it's your turn, and get a photo with swapped images. Remember, your image quality affect the outcome.</p>
		  <div class="shine"></div>
		</div>
	  </div>
    <script>
        const image = document.getElementById('imageMask');
        let drawingCanvas = document.getElementById('drawingCanvas');
        let ctx = drawingCanvas.getContext('2d');
        let isDrawing = false;

        // Load the image and set up the canvas
        image.onload = () => {
            drawingCanvas.width = image.width;
            drawingCanvas.height = image.height;
        };

        // Start drawing on left or right-click
        drawingCanvas.addEventListener('mousedown', (e) => {
            if (e.button === 0 || e.button === 2) {
                isDrawing = true;
                ctx.globalCompositeOperation = e.button === 0 ? 'source-over' : 'destination-out';
                ctx.strokeStyle = e.button === 0 ? document.getElementById('colorPicker').value : 'rgba(0, 0, 0, 1)';
                ctx.lineWidth = document.getElementById('sizeSlider').value; // Get the slider value
                ctx.lineJoin = 'round';
                ctx.lineCap = 'round';
                ctx.beginPath();
            }
        });

        // Continue drawing or erasing on mouse move
        drawingCanvas.addEventListener('mousemove', (e) => {
            if (isDrawing) {
                const x = e.clientX - drawingCanvas.getBoundingClientRect().left;
                const y = e.clientY - drawingCanvas.getBoundingClientRect().top;
                ctx.lineTo(x, y);
                ctx.stroke();
            }
        });

        // Stop drawing on left or right mouse up
        drawingCanvas.addEventListener('mouseup', () => {
            isDrawing = false;
            ctx.closePath();
        });

        // Prevent the default context menu on right-click
        drawingCanvas.addEventListener('contextmenu', (e) => {
            e.preventDefault(); // Prevent the default context menu
        });

        // Update the cursor to a circle matching the drawing size
        function updateCursor() {
            const size = ctx.lineWidth; // Set the cursor size based on the line width
            const cursorImage = createCursorImage(size);
            drawingCanvas.style.cursor = `url("${cursorImage}") ${size / 2} ${size / 2}, crosshair`;
        }

        // Initialize the jQuery UI slider
        $(function() {
            updateCursor(); // Initialize cursor
        });

        // Create a cursor image dynamically
        function createCursorImage(size) {
            const cursorCanvas = document.createElement('canvas');
            cursorCanvas.width = size;
            cursorCanvas.height = size;
            const cursorCtx = cursorCanvas.getContext('2d');

            cursorCtx.beginPath();
            cursorCtx.arc(size / 2, size / 2, size / 2, 0, Math.PI * 2);
            cursorCtx.strokeStyle = 'black';
            cursorCtx.lineWidth = 1;
            cursorCtx.stroke();
            cursorCtx.closePath();

            return cursorCanvas.toDataURL();
        }

        // Update the color when the color picker value changes
        document.getElementById('colorPicker').addEventListener('input', (e) => {
            if (isDrawing) {
                ctx.strokeStyle = e.target.value;
            }
        });

		// Initialize the jQuery UI slider
		const sizeSlider = $('#sizeSlider');
		const sliderValueElement = $('#sliderValue'); // Add a div to display the slider value

		// Log the slider value when it changes
		sizeSlider.on('input', function() {
			const sliderValue = sizeSlider.val(); // Get the current slider value
			const updatedCursorSize = sliderValue; // Adjust the multiplier as needed
			const cursorImage = createCursorImage(updatedCursorSize);
			drawingCanvas.style.cursor = `url("${cursorImage}") ${updatedCursorSize / 2} ${updatedCursorSize / 2}, crosshair`;
		});
		
		function previewImage(event, previewId) {
		  const imagePreview = document.getElementById(previewId);
		  const imageMask = document.getElementById('imageMask');
		  const drawingCanvas = document.getElementById('drawingCanvas'); // Get the drawingCanvas
		  const ctx = drawingCanvas.getContext('2d'); // Get the 2D drawing context

		  // Clear the canvas by setting its width and height
		  drawingCanvas.width = drawingCanvas.width + 1;
			  
		  // Clear the entire canvas
		  ctx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);;
		  
		  const file = event.target.files[0];
		  if (file) {
			imagePreview.style.display = 'block';
			imagePreview.src = URL.createObjectURL(file);
			
			// Copy the source and attributes from imagePreview to imageMask
			imageMask.src = imagePreview.src;
			imageMask.alt = imagePreview.alt;
			imageMask.style.width = imagePreview.style.width;
			imageMask.style.height = imagePreview.style.height;
			imageMask.style.objectFit = imagePreview.style.objectFit;
		  } else {
			imagePreview.style.display = 'none';
		  }
		}
		
		// Handle mouse wheel events to adjust the slider value
		drawingCanvas.addEventListener('wheel', (e) => {
			e.preventDefault();

			const sizeSlider = document.getElementById('sizeSlider');
			const step = 4;
			const currentValue = parseInt(sizeSlider.value);
			const newValue = e.deltaY > 0 ? currentValue - step : currentValue + step;
			const minValue = parseInt(sizeSlider.min);
			const maxValue = parseInt(sizeSlider.max);
			const clampedValue = Math.min(Math.max(newValue, minValue), maxValue);

			sizeSlider.value = clampedValue;

			ctx.lineWidth = clampedValue;
			updateCursor(clampedValue);
		}, { passive: false });
    </script>
	    <script>
		// Function to display the alert
		function showAlert() {
		  const neverShowAgain = localStorage.getItem('neverShowAgain');
		  if (!neverShowAgain) {
			const message = "Make sure to preview the mask. If the desired area isn't correct, then change the clothe detection prompt.";
			const userResponse = confirm(message + "\n\nDo you want to hide this message in the future?");
			
			if (userResponse) {
			  // Set a flag in localStorage to never show the alert again
			  localStorage.setItem('neverShowAgain', 'true');
			}
		  }
		}

		// Attach the showAlert function to the input field's click event
		document.getElementById('textModelPrompt').addEventListener('click', showAlert);
		
		// Function to display the alert
		function showSamplerAlert() {
		  const neverShowAgain = localStorage.getItem('neverShowSamplerErrorAgain');
		  if (!neverShowAgain) {
			const message = "This sampler will take 2 times more credits.";
			const userResponse = confirm(message + "\n\nDo you want to hide this message in the future?");
			
			if (userResponse) {
			  // Set a flag in localStorage to never show the alert again
			  localStorage.setItem('neverShowSamplerErrorAgain', 'true');
			}
		  }
		}

		// Attach the showAlert function to the input field's click event
		document.getElementById('samplerSelector').addEventListener('click', showSamplerAlert);
	  </script>
	  <script>
		// Function to save the advanced settings to Local Storage
		function saveSettings() {
		  const settings = {
			modeSelector: document.getElementById("modeSelector").value,
			genitaliaSelector: document.getElementById("genitaliaSelector").value,
			resSelector: document.getElementById("resSelector").value,
			breastSelector: document.getElementById("breastSelector").value,
			clotheDetectionSelector: document.getElementById("clotheDetectionSelector").value,
			textPrompt: document.getElementById("textPrompt").value,
			modelSelector: document.getElementById("modelSelector").value,
			samplerSelector: document.getElementById("samplerSelector").value,
			restoreBodySelector: document.getElementById("restoreBodySelector").value,
			tilingSelector: document.getElementById("tilingSelector").value,
			inpaintReferenceMode: document.getElementById("inpaintReferenceMode").value,
			pixelReference: document.getElementById("pixelReference").value,
			clipSkip: document.getElementById("clipSkip").value,
			configScale: document.getElementById("configScale").value,
			denoisingStrenght: document.getElementById("denoisingStrenght").value,
			dilateAmount: document.getElementById("dilateAmount").value,
		  };

		  // Convert the settings object to a JSON string and save it to Local Storage
		  localStorage.setItem("advancedSettings", JSON.stringify(settings));
		}

		// Function to load and apply the saved settings from Local Storage
		function loadSettings() {
		  const savedSettings = localStorage.getItem("advancedSettings");

		  if (savedSettings) {
			const settings = JSON.parse(savedSettings);

			// Apply the saved settings to the respective elements
			document.getElementById("modeSelector").value = settings.modeSelector;
			document.getElementById("genitaliaSelector").value = settings.genitaliaSelector;
			document.getElementById("resSelector").value = settings.resSelector;
			document.getElementById("breastSelector").value = settings.breastSelector;
			document.getElementById("clotheDetectionSelector").value = settings.clotheDetectionSelector;
			document.getElementById("textPrompt").value = settings.textPrompt;
			document.getElementById("modelSelector").value = settings.modelSelector;
			document.getElementById("samplerSelector").value = settings.samplerSelector;
			document.getElementById("restoreBodySelector").value = settings.restoreBodySelector;
			document.getElementById("tilingSelector").value = settings.tilingSelector;
			document.getElementById("inpaintReferenceMode").value = settings.inpaintReferenceMode;
			document.getElementById("pixelReference").value = settings.pixelReference;
			document.getElementById("clipSkip").value = settings.clipSkip;
			document.getElementById("configScale").value = settings.configScale;
			document.getElementById("denoisingStrenght").value = settings.denoisingStrenght;
			document.getElementById("dilateAmount").value = settings.dilateAmount;
		  }
		}

		// Add an event listener to the "sendResultsButton" to save settings when clicked
		document.getElementById("sendResultsButton").addEventListener("click", saveSettings);

		// Load and apply the saved settings when the page loads
		window.addEventListener("load", loadSettings);

		const triangle = document.getElementById('triangle');
		const triangleContainer = document.getElementById('triangleContainer');

		// Add a click event listener to toggle the triangle shape
		triangleContainer.addEventListener('click', () => {
		  triangle.classList.toggle('triangle-reversed');
		});

		const rectangle = document.querySelector('.rectangle'); // Select the rectangle element directly
		const expandedContent = document.querySelector('.expanded-content');

		let isExpanded = false;

		// Add a click event listener to the rectangle
		rectangle.addEventListener('click', (event) => {
		  // Check if the click target is the rectangle itself, not its children (expanded content)
		  if (event.target === rectangle) {
			toggleBox();
		  }
		});

		function toggleBox() {
		  if (isExpanded) {
			expandedContent.style.maxHeight = null; // Collapse the box
		  } else {
			expandedContent.style.maxHeight = expandedContent.scrollHeight + 'px'; // Expand the box to fit content
		  }
		  isExpanded = !isExpanded;
		}
		
		document.addEventListener('DOMContentLoaded', function () {
		  const clothesDescription = document.getElementById('clothesDescription'); // Get the clothes description paragraph
		  clothesDescription.style.display = 'none';
		  
		  const imageContainer = document.querySelector('.canvas-container');
		  imageContainer.style.display = 'none'; // Show the container
			  
		  const textPrompt = document.getElementById('textPrompt');
		  textPrompt.style.display = 'none';  // Set the example text and description for the textPrompt
		  
		  const expandedContent = document.querySelector('.expanded-content'); // Get the expanded content element
		  expandedContent.style.maxHeight = 0 + 'px'; // Expand the box

		  const clotheDetectionSelector = document.getElementById('clotheDetectionSelector');
		  clotheDetectionSelector.addEventListener('change', function () {
			if (this.value === 'manual') {
			  clothesDescription.style.display = 'none';
			  textPrompt.style.display = 'none';
			  imageContainer.style.display = 'block'; // Show the container
			} else if (this.value === 'prompt') {
			  clothesDescription.style.display = 'block';
			  textPrompt.style.display = 'block';
			  imageContainer.style.display = 'none'; // Show the container
			} else {
			  clothesDescription.style.display = 'none';
			  textPrompt.style.display = 'none';
			  imageContainer.style.display = 'none'; // Show the container
			}
		  });
		  
		  // Function to update the maxHeight based on the clotheDetectionSelector value
		  function updateMaxHeight() {
			expandedContent.style.maxHeight = expandedContent.scrollHeight + 'px'; // Expand the box
		  }

		  // Add an event listener to the clotheDetectionSelector
		  clotheDetectionSelector.addEventListener('change', updateMaxHeight);
		});
	  </script>
<script src="scripts/autoTranslate.js"></script></body>
	</html>